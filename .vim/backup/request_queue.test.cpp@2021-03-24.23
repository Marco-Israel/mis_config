#include <catch2/catch.hpp>
#include <gmock/gmock.h>
#include <flatbuffers/flatbuffers.h>
#include <botan/hex.h>
#include <botan/base64.h>
#include <botan/auto_rng.h>

#include "mocks/libcsme/msg/client/irequest_sender_mock.h"
#include "mocks/libcsme/net/iprotocolhandler_mock.h"
#include "util/util.hpp"
#include "libcsme/msg/server/request_queue.h"
#include "mocks/libcsme/msg/server/irequesthandler_mock.h"
#include "mocks/libcsme/net/imessage_sender_mock.h"
#include "util/MockScopeGuard.hpp"
#include "libcsme/msg/CryptoServiceCommon_generated.h"
#include "libcsme/msg/CryptoServiceRequest_generated.h"
#include "libcsme/msg/CryptoServiceResponse_generated.h"
#include "libcsme/msg/request_factory.h"
#include "libcsme/msg/response_factory.h"

namespace test
{
namespace unit
{
 namespace csme
    {
namespace msg
        {
namespace
            {
    sing namespace cs_test_utils;
    sing namespace testing;
    sing ::csme::msg::RequestFactory;
    sing ::csme::msg::RequestQueue;
    sing ::csme::msg::ResponseFactory;
    sing ::csme::net::ProtocolHandlerResult;

    EST_CASE( "libcsme/msg/server/RequestQueue.BasicTests" )

       SECTION( "CreateDestroy" )
       {
                RequestQueue dut( CreateLogger( ) );
       }

       SECTION( "StartStop" )
       {
           RequestQueue                dut( CreateLogger( ) );
           ::csme::platform::ThreadPtr thread = dut.Start( );
           REQUIRE( dut.IsStarted( ) );

           dut.Stop( );
           REQUIRE( not dut.IsStarted( ) );

           thread->join( );
       }

       SECTION( "Register" )
       {
           RequestQueue dut( CreateLogger( ) );

           REQUIRE( dut.RegisterRequestHandler( nullptr ) == false );
           REQUIRE( dut.RegisterRequestHandler( std::make_shared<test::IRequestHandlerMock>( ) ) );

           ::csme::platform::ThreadPtr thread = dut.Start( );
           dut.Stop( );
           thread->join( );
       }

       SECTION( "InvalidMessageEnvironment" )
       {
           RequestQueue                             dut( CreateLogger( ) );
           ::csme::platform::secure_vector<uint8_t> empty_message;

           // empty message
           REQUIRE( ProtocolHandlerResult::kErrorCloseConnection ==
                    dut.HandleIncomingMessage( empty_message, 0, nullptr ) );

           empty_message.push_back( 99 );
           // no response sender
           REQUIRE( ProtocolHandlerResult::kErrorCloseConnection ==
                    dut.HandleIncomingMessage( empty_message, empty_message.size( ), nullptr ) );

           auto sender     = std::make_shared<::test::IMessageSenderMock>( );
           auto mock_guard = MockScopeGuard( *sender );
           // not started
           REQUIRE( ProtocolHandlerResult::kErrorCloseConnection ==
                    dut.HandleIncomingMessage( empty_message, empty_message.size( ), sender ) );
       }


    TEST_CASE( "libcsme/msg/server/RequestQueue.MessageHandling" )

       RequestQueue dut( CreateLogger( ) );
       auto         test_logger       = CreateLogger( "test" );
       auto         sender            = std::make_shared<::test::IMessageSenderMock>( );
       auto         heartbeat_handler = std::make_shared<::test::IRequestHandlerMock>( );

       auto mock_guard = MockScopeGuard( *sender, *heartbeat_handler );

       REQUIRE( dut.RegisterRequestHandler( heartbeat_handler ) );

       ::csme::platform::ThreadPtr thread = dut.Start( );
       REQUIRE( dut.IsStarted( ) );

       ::csme::platform::secure_vector<uint8_t> message;
       ::csme::net::ProtocolHandlerResult       expected_handler_result =
           ::csme::net::ProtocolHandlerResult::kOk;

       SECTION( "EmptyMessage" )
       {
           auto sep = dut.GetMessageSeparator( );
           message.insert( message.end( ), sep.begin( ), sep.end( ) );

           expected_handler_result = ::csme::net::ProtocolHandlerResult::kErrorCloseConnection;
       }

       SECTION( "IncomingInvalidMessage" )
       {
           Botan::AutoSeeded_RNG rng;
           message = std::move( rng.random_vec( 512 ) );

           auto sep = dut.GetMessageSeparator( );
           message.insert( message.end( ), sep.begin( ), sep.end( ) );

           expected_handler_result = ::csme::net::ProtocolHandlerResult::kErrorCloseConnection;
       }

       SECTION( "UnverifiableRequest" )
       {
           auto                 builder = RequestFactory::CreateHeartbeatRequest( );
           std::vector<uint8_t> tmp_buffer( builder->GetBufferPointer( ),
                                            builder->GetBufferPointer( ) + builder->GetSize( ) );

           flatbuffers::Verifier verifier_before( tmp_buffer.data( ), tmp_buffer.size( ) );
           REQUIRE( ::csme::msg::VerifySizePrefixedCryptoServiceRequestBuffer( verifier_before ) );

           // Now that we have successfully forged a request, let's destroy it
           for ( size_t i = 0; i < 10; i++ ) {
               tmp_buffer[i] = '-';
           }

           // now we prove, that we managed to destroy the request
           flatbuffers::Verifier verifier_after( tmp_buffer.data( ), tmp_buffer.size( ) );
           REQUIRE( not::csme::msg::VerifySizePrefixedCryptoServiceRequestBuffer( verifier_after ) );

           std::string encoded_request = Botan::base64_encode( tmp_buffer.data( ), tmp_buffer.size( ) );
           test_logger->LogMessage(
               pfsw::LogSeverity::kInfo,
               std::string( "UnverifiableRequest: Encoded heartbeat message: " + encoded_request )
                   .c_str( ) );

           encoded_request += dut.GetMessageSeparator( );

           message.insert( message.end( ), encoded_request.begin( ), encoded_request.end( ) );

           EXPECT_CALL( *sender, CloseConnectionOnError( ) ).Times( 1 );
       }

       SECTION( "ValidMessages" )
       {
           SECTION( "NoHandlerForMessageFound" )
           {
               auto builder = RequestFactory::CreateRngDataRequest( 128 );

               std::string encoded_request =
                   Botan::base64_encode( builder->GetBufferPointer( ), builder->GetSize( ) );
               test_logger->LogMessage(
                   pfsw::LogSeverity::kInfo,
                   std::string( "Encoded heartbeat message: " + encoded_request ).c_str( ) );
               encoded_request += dut.GetMessageSeparator( );

               message.insert( message.end( ), encoded_request.begin( ), encoded_request.end( ) );

               EXPECT_CALL( *heartbeat_handler,
                            CanHandleRequest( ::csme::msg::AnyRequest::RngDataRequest ) )
                   .Times( 1 )
                   .WillOnce( Return( false ) );
               EXPECT_CALL( *sender, CloseConnectionOnError( ) ).Times( 1 );
           }

           SECTION( "Heartbeat" )
           {
               auto builder = RequestFactory::CreateHeartbeatRequest( );

               flatbuffers::Verifier verifier( builder->GetBufferPointer( ), builder->GetSize( ) );
               REQUIRE( ::csme::msg::VerifySizePrefixedCryptoServiceRequestBuffer( verifier ) );

               test_logger->LogMessage(
                   pfsw::LogSeverity::kInfo,
                   std::string( "Created heartbeat message: " +
                                Botan::hex_encode( builder->GetBufferPointer( ), builder->GetSize( ) ) )
                       .c_str( ) );

               std::string encoded_request =
                   Botan::base64_encode( builder->GetBufferPointer( ), builder->GetSize( ) );
               test_logger->LogMessage(
                   pfsw::LogSeverity::kInfo,
                   std::string( "Encoded heartbeat message: " + encoded_request ).c_str( ) );

               encoded_request += dut.GetMessageSeparator( );

               message.insert( message.end( ), encoded_request.begin( ), encoded_request.end( ) );

               EXPECT_CALL( *heartbeat_handler, CanHandleRequest( ::csme::msg::AnyRequest::Heartbeat ) )
                   .Times( 1 )
                   .WillOnce( Return( true ) );
               EXPECT_CALL( *heartbeat_handler, HandleRequest( _ ) )
                   .Times( 1 )
                   .WillOnce( Return( nullptr ) );
           }

           SECTION( "HeartbeatWithResponse" )
           {
               auto request = RequestFactory::CreateHeartbeatRequest( );

               std::string encoded_request =
                   Botan::base64_encode( request->GetBufferPointer( ), request->GetSize( ) );
               encoded_request += dut.GetMessageSeparator( );
               message.insert( message.end( ), encoded_request.begin( ), encoded_request.end( ) );

               auto response_fbb = ResponseFactory::CreateHeartbeatResponse( );
               EXPECT_CALL( *heartbeat_handler, CanHandleRequest( ::csme::msg::AnyRequest::Heartbeat ) )
                   .Times( 1 )
                   .WillOnce( Return( true ) );
               EXPECT_CALL( *heartbeat_handler, HandleRequest( _ ) )
                   .Times( 1 )
                   .WillOnce( Return( response_fbb ) );
               EXPECT_CALL( *sender, SendMessage( _ ) ).Times( 1 );
           }

           SECTION( "ExceptionInMessageHandler" )
           {
               auto request = RequestFactory::CreateHeartbeatRequest( );

               std::string encoded_request =
                   Botan::base64_encode( request->GetBufferPointer( ), request->GetSize( ) );
               encoded_request += dut.GetMessageSeparator( );
               message.insert( message.end( ), encoded_request.begin( ), encoded_request.end( ) );

               EXPECT_CALL( *heartbeat_handler, CanHandleRequest( ::csme::msg::AnyRequest::Heartbeat ) )
                   .Times( 1 )
                   .WillOnce( Return( true ) );
               EXPECT_CALL( *heartbeat_handler, HandleRequest( _ ) )
                   .Times( 1 )
                   .WillOnce( Throw( ::csme::msg::RequestHandlerException( "Something went wrong" ) ) );
               EXPECT_CALL( *sender, CloseConnectionOnError( ) ).Times( 1 );
           }
       }

       REQUIRE( expected_handler_result == dut.HandleIncomingMessage( message, message.size( ), sender ) );
       // Forces the processing thread to run
       std::this_thread::sleep_for( std::chrono::milliseconds( 10 ) );

       dut.Stop( );
       REQUIRE( not dut.IsStarted( ) );
       thread->join( );


    TEST_CASE( "libcsme/msg/server/RequestQueue.CreateHeartbeatMessage" )

       auto         logger = CreateLogger( );
       RequestQueue dut( logger );

       ::csme::platform::ThreadPtr thread = dut.Start( );
       REQUIRE( dut.IsStarted( ) );

       ::csme::platform::secure_vector<uint8_t> heartbeat_message;
       REQUIRE( ::csme::net::ProtocolHandlerResult::kOk ==
                dut.CreateHeartbeatMessage( heartbeat_message ) );

       // Strip out message separator
       heartbeat_message.resize( heartbeat_message.size( ) - dut.GetMessageSeparator( ).size( ) );
       // Decode message
       ::csme::platform::secure_vector<uint8_t> decoded_message = Botan::base64_decode(
           reinterpret_cast<const char *>( heartbeat_message.data( ) ), heartbeat_message.size( ), false );

       flatbuffers::Verifier verifier( decoded_message.data( ), decoded_message.size( ) );
       REQUIRE( ::csme::msg::VerifySizePrefixedCryptoServiceResponseBuffer( verifier ) );

       const ::csme::msg::CryptoServiceResponse *heartbeat_message_response =
           ::csme::msg::GetSizePrefixedCryptoServiceResponse( decoded_message.data( ) );
       REQUIRE( heartbeat_message_response->response_type( ) == ::csme::msg::AnyResponse::Heartbeat );

       dut.Stop( );
       REQUIRE( not dut.IsStarted( ) );
       thread->join( );
                }

            } // namespace
        }     // namespace msg
    }         // namespace csme
} // namespace unit
} // namespace test
