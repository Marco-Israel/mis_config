#include <algorithm>
#include <bits/stdint-uintn.h>
#include <catch2/catch.hpp>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <ostream>
//
#include "golden_certificates/root-ca-1.h"
#include "golden_certificates/sub-ca-1.h"
#include "golden_certificates/subscriber-1.h"

#include "silver_certificates/root-ca-1.h"
#include "silver_certificates/sub-ca-1.h"
#include "silver_certificates/subscriber-1.h"
//

extern "C" {
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "dumpasn1.h"
}

// Device under test
#include "libcryptoservice/util/static_map.hpp"

namespace test
{
namespace unit
{
    namespace crypto_service
    {
        namespace generators
        {
            namespace
            {
                TEST_CASE( "libcryptoservice/generators/certificates/certificate_compare" )
                {
                    int   pos           = 0;
                    FILE *output_stream = stdout;

                    /* NOTE: The dump and the compare asn1 tools are stream parser
                     *  working on file input only. You first need to create a
                     *  FILE pointer pointing to the memory buffer.
                     */

                    /*
                     *  NOTE: The silver cerificates are only dummy till
                     *  this cryptlib is able to generate own certificates.
                     */

                    SECTION( "Root Certificate compare" )
                    {
                        FILE *root_file[2] = {
                            fmemopen( golden_certificates_root_ca_1_der, golden_certificates_root_ca_1_der_len, "rb+" ),
                            fmemopen( silver_certificates_root_ca_1_der, silver_certificates_root_ca_1_der_len, "rb+" )
                        };

                        /*You can produce a verbose output print the howl *differences to the output stream.*/
                        pos = compareasn1( root_file[0], root_file[1], output_stream, TRUE );
                        // REQUIRE(pos == 0 );  /**< In a normal case, we expect a failing test if certificates are not
                        // equal */
                        REQUIRE( pos > 0);
                    }

                    SECTION( "Sub CA  certificate compare" )
                    {
                        FILE *sub_file[2] = {
                            fmemopen( golden_certificates_sub_ca_1_der, golden_certificates_sub_ca_1_der_len, "rb+" ),
                            fmemopen( silver_certificates_sub_ca_1_der, silver_certificates_sub_ca_1_der_len, "rb+" )
                        };

                        /*
                         * You can produce a simple hit only to notice the files
                         * are different by starting at given offset.
                         */
                        pos = compareasn1( sub_file[0], sub_file[1], output_stream, FALSE );
                        // REQUIRE(pos == 0 );  /**< In a normal case, we expect a failing test if certificates are not
                        // equal */
                        REQUIRE( pos > 0);
                    }

                    SECTION( "SUBSCRIBER Certificate compare" )
                    {
                        FILE *subscriber_file[2] = { fmemopen( golden_certificates_subscriber_1_der,
                                                               golden_certificates_subscriber_1_der_len,
                                                               "rb+" ),
                                                     fmemopen( silver_certificates_subscriber_1_der,
                                                               silver_certificates_subscriber_1_der_len,
                                                               "rb+" ) };
                        /*
                         * You can redirect the output to an other stream (e.g.
                         * a FILE PTR or you can ignore the output by set 'output' to NULL
                         * and handle only the returned value holding the
                         * offset to the first different byte or null in case of
                         * no differences.
                         */
                        std::cout << "\n\nSUBSCRIBER Certificate:" << std::endl;
                        pos = compareasn1( subscriber_file[0], subscriber_file[1], NULL, FALSE );
                        // REQUIRE(pos == 0 );  /**< In a normal case, we expect a failing test if certificates are not
                         // equal */
                        REQUIRE( pos > 0 );
                    }
                }
            } // namespace
        }     // namespace generators
    }         // namespace crypto_service
} // namespace unit
} // namespace test
