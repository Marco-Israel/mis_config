#include "libcsme/net/server/net_api.h"
#include "libcsme/platform/shared_types.h"
#include "libcsme/platform/log/macros.h"

namespace csme
{
namespace net
{
    NetApi::NetApi( ProtocolHandlerPtr protocol_handler, LogPtr logger, const NetApiConfig *const config )
        : v4_endpoint_( new asio::ip::tcp::endpoint( asio::ip::tcp::v4( ), tcp_port_ ) )
        , v6_endpoint_( new asio::ip::tcp::endpoint( asio::ip::tcp::v6( ), tcp_port_ ) )
        , protocol_handler_( std::move( protocol_handler ) )
        , log_( std::move( logger ) )
        , session_pool_( std::make_shared<SessionPool>( max_concurrent_connections_ ) )
    {
        if ( config != nullptr ) {
            IGNORE_RETURN_VALUE( SetTcpListenPort( config->tcp_port( ) ) );

            const NetApiResourceConfig *const resource_config = config->resource_config( );
            IGNORE_RETURN_VALUE( SetMaxConcurrentConnections( resource_config->max_concurrent_connections( ) ) );
            IGNORE_RETURN_VALUE( SetConnectionThreadPoolSize( resource_config->thread_pool_size( ) ) );

            const NetApiKeepAliveConfig *const keepalive_config = config->keepalive_config( );
            IGNORE_RETURN_VALUE( SetHeartbeatInterval( keepalive_config->hearbeat_interval_ms( ) ) );
            IGNORE_RETURN_VALUE( SetConnectionTimeout( keepalive_config->connection_timeout_ms( ) ) );
        }
    }

    // Starts the servers. Adds all created threads into given thread pool.
    bool NetApi::Start( std::vector<ThreadPtr> &thread_pool )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Network API already started" );
            return false;
        }

        if ( connection_thread_pool_size_ > max_concurrent_connections_ ) {
            //lint -save -e9117 we're ok with these implicit conversions
            LOG_WARN_STR( "Thread pool size is bigger (" + std::to_string( connection_thread_pool_size_ ) +
                          ") than allowed amount of concurrent connections (" +
                          std::to_string( max_concurrent_connections_ ) + "). Decreasing thread pool size." );
            //lint -restore
            connection_thread_pool_size_ = static_cast<uint8_t>( max_concurrent_connections_ );
        }

        try {
            if ( v4_endpoint_ ) {
                //lint -save -e9117 we're ok with these implicit conversions
                LOG_INFO_STR( "Starting IPv4 network API on port " + v4_endpoint_->address( ).to_string( ) + ":" +
                              std::to_string( v4_endpoint_->port( ) ) );
                //lint -restore
                ipv4_server_ = ServerPtr( new Server( heartbeat_interval_,
                                                      connection_timeout_,
                                                      io_context_,
                                                      *v4_endpoint_,
                                                      protocol_handler_,
                                                      session_pool_,
                                                      log_ ) );
                ipv4_server_->Start( );
            }

            if ( v6_endpoint_ ) {
                //lint -save -e9117 we're ok with these implicit conversions
                LOG_INFO_STR( "Starting IPv6 network API on " + v6_endpoint_->address( ).to_string( ) + ":" +
                              std::to_string( v6_endpoint_->port( ) ) );
                //lint -restore
                ipv6_server_ = ServerPtr( new Server( heartbeat_interval_,
                                                      connection_timeout_,
                                                      io_context_,
                                                      *v6_endpoint_,
                                                      protocol_handler_,
                                                      session_pool_,
                                                      log_ ) );
                ipv6_server_->Start( );
            }

            if ( ipv4_server_ || ipv6_server_ ) {
                for ( auto i = connection_thread_pool_size_; i > 0U; --i ) {
                    thread_pool.push_back( std::move(
                        ThreadPtr( new std::thread( [this] { IGNORE_RETURN_VALUE( io_context_.run( ) ); } ) ) ) );
                }

                is_started_ = true;
            }
        } catch ( std::exception &e ) {
            LOG_FATAL_STR( "Could not create server, reason: " + std::string( e.what( ) ) );
            ipv4_server_ = nullptr;
            ipv6_server_ = nullptr;
            is_started_  = false;
        }

        return is_started_;
    }

    bool NetApi::Stop( )
    {
        if ( !is_started_ ) {
            LOG_ERROR_STR( "API not started." );
            return false;
        }

        io_context_.stop( );

        if ( ipv4_server_ ) {
            ipv4_server_->Stop( );
            ipv4_server_ = nullptr;
        }

        if ( ipv6_server_ ) {
            ipv6_server_->Stop( );
            ipv6_server_ = nullptr;
        }

        is_started_ = false;
        return true;
    }

    void NetApi::ResetIoContext( )
    {
        io_context_.reset( );
    }

    bool NetApi::SetConnectionThreadPoolSize( uint8_t const size )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        connection_thread_pool_size_ = size;
        return true;
    }

    bool NetApi::SetTcpListenPort( uint16_t const port )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        tcp_port_    = port;
        v4_endpoint_ = std::make_shared<asio::ip::tcp::endpoint>( asio::ip::tcp::v4( ), tcp_port_ );
        v6_endpoint_ = std::make_shared<asio::ip::tcp::endpoint>( asio::ip::tcp::v6( ), tcp_port_ );

        return true;
    }

    bool NetApi::SetIpV4Endpoint( std::shared_ptr<tcp::endpoint> endpoint )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        v4_endpoint_ = std::move( endpoint );
        return true;
    }

    bool NetApi::SetIpV6Endpoint( std::shared_ptr<tcp::endpoint> endpoint )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        v6_endpoint_ = std::move( endpoint );
        return true;
    }

    bool NetApi::SetMaxConcurrentConnections( uint16_t const max_connections )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        max_concurrent_connections_ = max_connections;
        return true;
    }

    bool NetApi::SetHeartbeatInterval( uint16_t const interval_ms )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        heartbeat_interval_ = std::chrono::milliseconds( interval_ms );
        return true;
    }

    bool NetApi::SetConnectionTimeout( uint16_t const timeout_ms )
    {
        if ( is_started_ ) {
            LOG_ERROR_STR( "Configuration changes are not possible after start" );
            return false;
        }

        connection_timeout_ = std::chrono::milliseconds( timeout_ms );
        return true;
    }

} // namespace net
} // namespace csme
