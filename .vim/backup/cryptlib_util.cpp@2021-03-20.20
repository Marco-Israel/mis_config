
#include "cryptlib_util.h"

#include <cstring>
#include "cryptlib.h"

namespace cryptlib
{
namespace util
{
    int createDeviceSession( CRYPT_DEVICE *userDevice, const char *devicePassword )
    {
        CRYPT_DEVICE cryptDevice;
        int          status;

        /* Clear the return value */
        *userDevice = -1;

        /* Open a session with the device */
        status = cryptDeviceOpen( &cryptDevice, CRYPT_UNUSED, CRYPT_DEVICE_HARDWARE, "Botan crypto core" );
        if ( cryptStatusError( status ) ) return ( status );

        /* Log on to the device */
        status = cryptSetAttributeString(
            cryptDevice, CRYPT_DEVINFO_AUTHENT_USER, devicePassword, strlen( devicePassword ) );
        if ( cryptStatusError( status ) ) {
            cryptDeviceClose( cryptDevice );
            return ( status );
        }

        /* Return the device object to the caller */
        status = cryptSetAttributeString( cryptDevice, CRYPT_DEVINFO_INITIALISE, "", 1 );
        if ( cryptStatusError( status ) ) {
            cryptDeviceClose( cryptDevice );
            return ( status );
        }

        *userDevice = cryptDevice;
        return ( CRYPT_OK );
    }

    int getPrivateKey( CRYPT_CONTEXT *privateKeyContext,
                       const char *   privKeysetName,
                       const char *   privKeyLabel,
                       const char *   privKeyPassword )
    {
        CRYPT_CONTEXT cryptContext;
        int           status;

        /* Clear the return value */
        *privateKeyContext = -1;

        /* Fetch the private key. If a filename is given then we assume that the source is a file keyset, otherwise it's
         * a device */
        if ( privKeysetName != NULL ) {
            CRYPT_KEYSET cryptKeyset;

            /* Fetch the private key from the keyset */
            status =
                cryptKeysetOpen( &cryptKeyset, CRYPT_UNUSED, CRYPT_KEYSET_FILE, privKeysetName, CRYPT_KEYOPT_READONLY );
            if ( cryptStatusOK( status ) ) {
                status =
                    cryptGetPrivateKey( cryptKeyset, &cryptContext, CRYPT_KEYID_NAME, privKeyLabel, privKeyPassword );
                cryptKeysetClose( cryptKeyset );
            }
        } else {
            CRYPT_DEVICE cryptDevice;

            /* Fetch the private key from the device */
            status = createDeviceSession( &cryptDevice, privKeyPassword );
            if ( cryptStatusOK( status ) ) {
                status = cryptGetPrivateKey( cryptDevice, &cryptContext, CRYPT_KEYID_NAME, privKeyLabel, NULL );
                cryptDeviceClose( cryptDevice );
            }
        }
        if ( cryptStatusError( status ) ) return ( status );

        /* Return the private key to the caller */
        *privateKeyContext = cryptContext;
        return ( CRYPT_OK );
    }

    int getPublicKey( CRYPT_CERTIFICATE *userCertificate,
                      const char *       pubKeysetName,
                      const char *       pubKeyLabel,
                      const char *       devicePassword )
    {
        CRYPT_CERTIFICATE cryptCertificate;
        int               status;

        /* Clear the return value */
        *userCertificate = -1;

        /* Fetch the public key/certificate. If a filename is given then we assume that the source is a public-key
         * keyset, otherwise it's a device */
        if ( pubKeysetName != NULL ) {
            CRYPT_KEYSET cryptKeyset;

            /* Fetch the public key/certificate from the keyset */
            status = cryptKeysetOpen(
                &cryptKeyset, CRYPT_UNUSED, CRYPT_KEYSET_DATABASE, pubKeysetName, CRYPT_KEYOPT_READONLY );
            if ( cryptStatusOK( status ) ) {
                status = cryptGetPublicKey( cryptKeyset, &cryptCertificate, CRYPT_KEYID_NAME, pubKeyLabel );
                cryptKeysetClose( cryptKeyset );
            }
        } else {
            CRYPT_DEVICE cryptDevice;

            /* Fetch the public key/certificate from the device */
            status = createDeviceSession( &cryptDevice, devicePassword );
            if ( cryptStatusOK( status ) ) {
                status = cryptGetPublicKey( cryptDevice, &cryptCertificate, CRYPT_KEYID_NAME, pubKeyLabel );
                cryptDeviceClose( cryptDevice );
            }
        }
        if ( cryptStatusError( status ) ) return ( status );

        /* Return the public key/certificate to the caller */
        *userCertificate = cryptCertificate;
        return ( CRYPT_OK );
    }

    int publishPublicKey( const char *publicKeysetName, const CRYPT_CERTIFICATE cryptCertificate )
    {
        CRYPT_KEYSET cryptKeyset;
        char         name[128];
        int          nameLen, status;

        /* Open a connection to the public-key keyset */
        status =
            cryptKeysetOpen( &cryptKeyset, CRYPT_UNUSED, CRYPT_KEYSET_DATABASE, publicKeysetName, CRYPT_KEYOPT_NONE );
        if ( cryptStatusError( status ) ) return ( status );

        /* Clear any existing certificates under this name that may already be present. This is useful for the sample
         * code when re-running it multiple times and creating new keys on each run */
        status = cryptGetAttributeString( cryptCertificate, CRYPT_CERTINFO_COMMONNAME, name, &nameLen );
        if ( cryptStatusOK( status ) ) {
            name[nameLen] = '\0';
            (void)cryptDeleteKey( cryptKeyset, CRYPT_KEYID_NAME, name );
        }

        /* Publish the certificate to the keyset */
        status = cryptAddPublicKey( cryptKeyset, cryptCertificate );
        cryptKeysetClose( cryptKeyset );
        return ( status );
    }

} /* namespace util */

} /* namespace cryptlib */