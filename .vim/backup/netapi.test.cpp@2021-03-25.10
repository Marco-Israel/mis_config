//#include <catch2/catch.hpp>
//#include <chrono>
//#include <cstdlib>
//#include <gmock/gmock-cardinalities.h>
//#include <gmock/gmock.h>
//#include <vector>
//#include <flatbuffers/flatbuffers.h>
//
//#include "libcsme/net/iprotocol_handler.h"
//#include "mocks/libcsme/net/iprotocolhandler_mock.h"
//#include "libcsme/net/server/net_api.h"
//#include "libcsme/platform/shared_types.h"
//#include "util/MockScopeGuard.hpp"
//#include "libcsme/net/server/tcp_test_client.hpp"
//#include "libcsme/net/server/port_provider.hpp"
//#include "util/TestRunConfiguration.h"
//#include "libcsme/net/server/netapi_config_generated.h"
//#include "util/util.hpp"
//
//#define SHUTDOWN_DUT( )                  \
//    dut.Stop( );                         \
//    for ( auto &thread : thread_pool ) { \
//        thread->join( );                 \
//    }                                    \
//    void( )
//namespace test
//{
//namespace unit
//{
//    namespace libcsme
//    {
//        namespace net
//        {
//            namespace
//            {
//                using ::csme::net::NetApi;
//                using ::csme::net::ProtocolHandlerResult;
//                using namespace testing;
//                using namespace cs_test_utils;
//                static csme::platform::secure_vector<uint8_t> heartbeat_message = { 'p', 'i', 'n', 'g', '!', '\n' };
//
//                uint16_t                       tcp_port = -1;
//                std::shared_ptr<tcp::endpoint> v4_endpoint;
//                std::shared_ptr<tcp::endpoint> v6_endpoint;
//
//                void PrepareNetworkEndpoints( )
//                {
//                    int32_t free_port = FindFreePort( );
//                    REQUIRE( free_port != -1 );
//                    REQUIRE( free_port > 0 );
//                    REQUIRE( free_port <= 65535 );
//                    tcp_port = static_cast<uint16_t>( free_port );
//
//                    asio::error_code ec;
//
//                    v4_endpoint =
//                        std::make_shared<tcp::endpoint>( asio::ip::make_address_v4( "127.0.0.1", ec ), tcp_port );
//                    REQUIRE( !ec );
//                    v6_endpoint = std::make_shared<tcp::endpoint>( asio::ip::make_address_v6( "::1", ec ), tcp_port );
//                    REQUIRE( !ec );
//                }
//
//                TEST_CASE( "libcsme/net/server/NetApi.BasicTests" )
//                {
//                    SECTION( "CanFindFreePort" )
//                    {
//                        PrepareNetworkEndpoints( );
//                    }
//
//                    SECTION( "CreateDestroyNoStart" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//                        NetApi                                 dut( protocol_mock, logger_mock );
//                    }
//
//                    SECTION( "StartStopNoConnection" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//                        NetApi                                 dut( protocol_mock, logger_mock );
//
//                        dut.SetIpV4Endpoint( v4_endpoint );
//                        dut.SetIpV6Endpoint( v6_endpoint );
//                        REQUIRE( v4_endpoint->port( ) == v6_endpoint->port( ) );
//                        dut.Start( thread_pool );
//                        SHUTDOWN_DUT( );
//                    }
//
//                    SECTION( "AdjustConnectionThreadPool" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//                        NetApi                                 dut( protocol_mock, logger_mock );
//                        dut.SetIpV4Endpoint( v4_endpoint );
//                        dut.SetIpV6Endpoint( v6_endpoint );
//
//                        // If the number of max allowed concurrent connections is smaller, than the size of the thread
//                        // pool, the size of the thread pool is redused.
//                        auto max_concurrent_connections = 5;
//                        dut.SetMaxConcurrentConnections( max_concurrent_connections );
//                        dut.SetConnectionThreadPoolSize( 50 );
//
//                        dut.Start( thread_pool );
//
//                        REQUIRE( thread_pool.size( ) == max_concurrent_connections );
//                        SHUTDOWN_DUT( );
//                    }
//
//                    SECTION( "StartFailsWithNoEndpoints" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//                        NetApi                                 dut( protocol_mock, logger_mock );
//
//                        dut.SetIpV4Endpoint( nullptr );
//                        dut.SetIpV6Endpoint( nullptr );
//                        REQUIRE( false == dut.Start( thread_pool ) );
//                        SHUTDOWN_DUT( );
//                    }
//
//                    SECTION( "Reconfiguration not possible and configuration errors" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//                        NetApi                                 dut( protocol_mock, logger_mock );
//
//                        REQUIRE( true == dut.SetTcpListenPort( tcp_port ) );
//                        dut.SetIpV4Endpoint( v4_endpoint );
//                        dut.SetIpV6Endpoint( nullptr );
//                        REQUIRE( true == dut.Start( thread_pool ) );
//                        REQUIRE( false == dut.SetConnectionThreadPoolSize( 99 ) );
//                        REQUIRE( false == dut.SetTcpListenPort( 99 ) );
//                        REQUIRE( false == dut.SetIpV4Endpoint( nullptr ) );
//                        REQUIRE( false == dut.SetIpV6Endpoint( nullptr ) );
//                        REQUIRE( false == dut.SetMaxConcurrentConnections( 99 ) );
//                        REQUIRE( false == dut.SetHeartbeatInterval( 99 ) );
//                        REQUIRE( false == dut.SetConnectionTimeout( 99 ) );
//                        REQUIRE( false == dut.Start( thread_pool ) );
//                        SHUTDOWN_DUT( );
//                    }
//
//                    SECTION( "Configuration using flatbuffers config" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//                        std::vector<csme::platform::ThreadPtr> thread_pool;
//
//                        flatbuffers::FlatBufferBuilder builder;
//                        auto resource_config  = csme::net::CreateNetApiResourceConfig( builder, 10, 1 );
//                        auto keepalive_config = csme::net::CreateNetApiKeepAliveConfig( builder, 999, 9999 );
//                        auto config_offset =
//                            csme::net::CreateNetApiConfig( builder, 50000, resource_config, keepalive_config );
//                        builder.Finish( config_offset );
//
//                        uint8_t *config_buffer = builder.GetBufferPointer( );
//                        size_t   buffer_size   = builder.GetSize( );
//
//                        flatbuffers::Verifier verifier( config_buffer, buffer_size );
//                        REQUIRE( csme::net::VerifyNetApiConfigBuffer( verifier ) );
//
//                        auto   config = csme::net::GetNetApiConfig( config_buffer );
//                        NetApi dut( protocol_mock, logger_mock, config );
//                    }
//                }
//
//                void WaitForMessages( TcpTestClientPtr test_client,
//                                      uint8_t          expected_messages,
//                                      uint16_t         timeout_ms            = 1000,
//                                      uint16_t         heartbeat_interval_ms = 100 )
//                {
//                    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now( );
//                    while ( test_client->MessageLogbook.size( ) < expected_messages &&
//                            ( std::chrono::duration_cast<std::chrono::milliseconds>( std::chrono::steady_clock::now( ) -
//                                                                                     start )
//                                  .count( ) <= timeout_ms ) ) {
//                        std::this_thread::sleep_for( std::chrono::milliseconds( heartbeat_interval_ms ) );
//                    }
//                }
//
//                TEST_CASE( "libcsme/net/server/NetApi.Advanced-Timeouts" )
//                {
//                    PrepareNetworkEndpoints( );
//
//                    // Start a simple client, that does not send heartbeats. It should be disconnected, after the
//                    // connection deadline of the server expired.
//                    auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                    auto mock_guard    = MockScopeGuard( *protocol_mock );
//                    auto logger_mock   = CreateLogger( );
//                    std::vector<csme::platform::ThreadPtr> thread_pool;
//
//                    uint16_t heartbeat_interval_ms = 100;
//                    uint16_t connection_timeout_ms = 500;
//
//                    uint8_t expected_heartbeats = ( connection_timeout_ms / heartbeat_interval_ms ) - 1;
//
//                    NetApi dut( protocol_mock, logger_mock );
//                    dut.SetHeartbeatInterval( heartbeat_interval_ms );
//                    dut.SetConnectionTimeout( connection_timeout_ms );
//                    dut.SetIpV4Endpoint( v4_endpoint );
//                    dut.SetIpV6Endpoint( v6_endpoint );
//                    dut.Start( thread_pool );
//
//                    // common expectation
//                    EXPECT_CALL( *protocol_mock, GetMessageSeparator( ) ).WillRepeatedly( Return( "\n" ) );
//                    SECTION( "TimeoutTests" )
//                    {
//                        SECTION( "AwaitConnectionTimeoutWithNoHeartbeatsSent" )
//                        {
//                            TcpTestClientPtr test_client =
//                                TcpTestClientPtr( new TcpTestClient( protocol_mock, CreateLogger( "client" ) ) );
//                            test_client->SetTcpPort( tcp_port );
//                            csme::platform::ThreadPtr test_client_thread = test_client->Start( );
//
//                            // server expectations
//                            // if ( !test::unit::DisableHardTimingChecks ) {
//                            //     EXPECT_CALL( *protocol_mock, CreateHeartbeatMessage( _ ) )
//                            //         .Times( expected_heartbeats )
//                            //         .WillRepeatedly( DoAll( SetArgReferee<0>( heartbeat_message ),
//                            //                                 Return( ProtocolHandlerResult::kOk ) ) );
//                            // } else {
//                            EXPECT_CALL( *protocol_mock, CreateHeartbeatMessage( _ ) )
//                                .WillRepeatedly( DoAll( SetArgReferee<0>( heartbeat_message ),
//                                                        Return( ProtocolHandlerResult::kOk ) ) );
//                            // }
//
//                            WaitForMessages( test_client, expected_heartbeats );
//                            // Let's sleep a bit more to give the server some time to shut us down.
//                            std::this_thread::sleep_for(
//                                std::chrono::milliseconds( heartbeat_interval_ms + ( heartbeat_interval_ms / 4 ) ) );
//
//                            REQUIRE( !test_client->IsStarted( ) );
//
//                            if ( !test::unit::DisableHardTimingChecks ) {
//                                int64_t milliseconds_from_start =
//                                    std::chrono::duration_cast<std::chrono::milliseconds>(
//                                        test_client->StopTimePoint - test_client->ConnectedTimePoint )
//                                        .count( );
//
//                                REQUIRE( milliseconds_from_start < ( connection_timeout_ms + heartbeat_interval_ms ) );
//                            } else {
//                                WARN( "Hard timing checks are disabled, did not check wether the client disconnected "
//                                      "in time." );
//                            }
//
//                            // Server should have closed our connection, because we did not answer any of it's
//                            // heartbeats or messages.
//                            REQUIRE( test_client->LastOccurredError == asio::error::eof );
//                            test_client_thread->join( );
//                        }
//
//                        SECTION( "AwaitConnectionTimeoutWithSingleHeartbeatsSent" )
//                        {
//                            TcpTestClientPtr test_client =
//                                TcpTestClientPtr( new TcpTestClient( protocol_mock, CreateLogger( "client" ) ) );
//                            test_client->SetTcpPort( tcp_port );
//                            csme::platform::ThreadPtr test_client_thread = test_client->Start( );
//
//                            // server expectations
//                            // if ( !test::unit::DisableHardTimingChecks ) {
//                            //     EXPECT_CALL( *protocol_mock, CreateHeartbeatMessage( _ ) )
//                            //         .Times( expected_heartbeats + 2 )
//                            //         .WillRepeatedly( DoAll( SetArgReferee<0>( heartbeat_message ),
//                            //                                 Return( ProtocolHandlerResult::kOk ) ) );
//                            // } else {
//                            // If the timing is messed up, we cannot check, how many heartbeats will be created.
//                            EXPECT_CALL( *protocol_mock, CreateHeartbeatMessage( _ ) )
//                                .WillRepeatedly( DoAll( SetArgReferee<0>( heartbeat_message ),
//                                                        Return( ProtocolHandlerResult::kOk ) ) );
//                            // }
//
//                            // Let's wait for the first received heartbeat
//                            EXPECT_CALL( *protocol_mock, HandleIncomingMessage( _, _, _ ) )
//                                .Times( 1 )
//                                .WillOnce( Return(
//                                    ProtocolHandlerResult::kOk ) ); // we do _NOT_ fill the response message, as we've
//                            // got nothing to say to the heartbeat message.
//                            WaitForMessages( test_client, 1 );
//
//                            // Client replies with a single heartbeat
//                            test_client->SendMessage( "ping!\n" );
//
//                            WaitForMessages( test_client, 4 );
//
//                            // Let's sleep a bit more to give the server some time to shut us down.
//                            std::this_thread::sleep_for(
//                                std::chrono::milliseconds( heartbeat_interval_ms + ( heartbeat_interval_ms * 4u ) ) );
//
//                            REQUIRE( test_client->IsStopped( ) );
//                            // Server should have closed our connection, because we did not answer any of it's
//                            // heartbeats or messages.
//                            REQUIRE( test_client->LastOccurredError == asio::error::eof );
//                            test_client_thread->join( );
//                        }
//                    }
//
//                    SHUTDOWN_DUT( );
//                }
//
////                TEST_CASE( "libcsme/net/server/NetApi.Advanced-Communication-Communication" )
////                {
////                    PrepareNetworkEndpoints( );
////
////                    // Start a simple client, that does not send heartbeats. It should be disconnected, after the
////                    // connection deadline of the server expired.
////                    auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
////                    auto mock_guard    = MockScopeGuard( *protocol_mock );
////                    auto logger_mock   = CreateLogger( );
////                    std::vector<csme::platform::ThreadPtr> thread_pool;
////
////                    uint16_t heartbeat_interval_ms = 100;
////                    uint16_t connection_timeout_ms = 300;
////
////                    uint8_t expected_heartbeats = ( connection_timeout_ms / heartbeat_interval_ms ) - 1;
////
////                    NetApi dut( protocol_mock, logger_mock );
////                    dut.SetHeartbeatInterval( heartbeat_interval_ms );
////                    dut.SetConnectionTimeout( connection_timeout_ms );
////                    dut.SetIpV4Endpoint( v4_endpoint );
////                    dut.SetIpV6Endpoint( v6_endpoint );
////                    dut.Start( thread_pool );
////
////                    SECTION( "Communication" )
////                    {
////                        // common expectation. TODO: THIS FIALS :
////                        EXPECT_CALL( *protocol_mock, GetMessageSeparator( ) ).WillRepeatedly( Return( "\n" ) );
////
////                        std::string                            response_str = "pong!";
////                        csme::platform::secure_vector<uint8_t> response_vec;
////                        response_vec.insert( response_vec.end( ), response_str.begin( ), response_str.end( ) );
////                        response_vec.push_back( '\n' );
////
////                        TcpTestClientPtr test_client =
////                            TcpTestClientPtr( new TcpTestClient( protocol_mock, CreateLogger( "client" ) ) );
////                        test_client->SetTcpPort( tcp_port );
////                        csme::platform::ThreadPtr test_client_thread = test_client->Start( );
////
////                        EXPECT_CALL( *protocol_mock, HandleIncomingMessage( _, _, _ ) )
////                            .Times( 1 )
////                            .WillOnce( DoAll( Invoke( [&]( Unused, Unused, csme::net::MessageSenderPtr sender ) {
////                                                  sender->SendMessage( response_vec );
////                                              } ),
////                                              Return( ProtocolHandlerResult::kOk ) ) );
////
////                        test_client->SendMessage( "ping!\n" );
////                        WaitForMessages( test_client, 1 );
////
////                        REQUIRE( test_client->MessageLogbook.size( ) == 1 );
////                        std::string last_received_message = test_client->MessageLogbook[0].second;
////                        REQUIRE( response_str == last_received_message );
////                        test_client->Stop( );
////                        test_client_thread->join( );
////
////                    // First clear all references on the shard_ptr which are hold by the "ECPACT_CALL"
////                    // macro but not truly be released. Afterward spend time to deconstruct all objects
////                    //in case when the CPU or server load is hight e.g. by stress tests
////                    Mock::VerifyAndClearExpectations(protocol_mock.get());
////                    std::this_thread::sleep_for(
////                        std::chrono::milliseconds( std::chrono::milliseconds (100 ) ) ) ;
////                    SHUTDOWN_DUT( );
////                    }
////                }
////
////                TEST_CASE( "libcsme/net/server/NetApi.Advanced-Communication-ProtocolHandleErrors" )
////                {
////                    PrepareNetworkEndpoints( );
////
////                    // Start a simple client, that does not send heartbeats. It should be disconnected, after the
////                    // connection deadline of the server expired.
////                    auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
////                    auto mock_guard    = MockScopeGuard( *protocol_mock );
////                    auto logger_mock   = CreateLogger( );
////                    std::vector<csme::platform::ThreadPtr> thread_pool;
////
////                    uint16_t heartbeat_interval_ms = 100;
////                    uint16_t connection_timeout_ms = 400;
////
////                    uint8_t expected_heartbeats = ( connection_timeout_ms / heartbeat_interval_ms ) - 1;
////
////                    NetApi dut( protocol_mock, logger_mock );
////                    dut.SetHeartbeatInterval( heartbeat_interval_ms );
////                    dut.SetConnectionTimeout( connection_timeout_ms );
////                    dut.SetIpV4Endpoint( v4_endpoint );
////                    dut.SetIpV6Endpoint( v6_endpoint );
////                    dut.Start( thread_pool );
////
////                    // common expectation. TODO: THIS FIALS :
////                    EXPECT_CALL( *protocol_mock, GetMessageSeparator( ) ).WillRepeatedly( Return( "\n" ) );
////
////                    SECTION( "ProtocolHandlerErrors" )
////                    {
////                        SECTION( "ProtocolHandlerErrorClosesConnection" )
////                        {
////                            TcpTestClientPtr test_client =
////                                TcpTestClientPtr( new TcpTestClient( protocol_mock, CreateLogger( "client" ) ) );
////                            test_client->SetTcpPort( tcp_port );
////                            csme::platform::ThreadPtr test_client_thread = test_client->Start( );
////
////                            EXPECT_CALL( *protocol_mock, HandleIncomingMessage( _, _, _ ) )
////                                .Times( 1 )
////                                .WillOnce( Return( ProtocolHandlerResult::kErrorCloseConnection ) );
////
////                            test_client->SendMessage( "ping!\n" );
////                            std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );
////
////                            REQUIRE( test_client->IsStopped( ) );
////                            test_client_thread->join( );
////
////                            // First clear all references on the shard_ptr which are hold by the "ECPACT_CALL"
////                            // macro but not truly be released. Afterward spend time to deconstruct all objects
////                            //in case when the CPU or server load is hight e.g. by stress tests
////                            Mock::VerifyAndClearExpectations(protocol_mock.get());
////                            std::this_thread::sleep_for(
////                            std::chrono::milliseconds( std::chrono::milliseconds (100 ) ) ) ;
////                        }
////
////                        SECTION( "CreatHeartbeatError" )
////                        {
////                            TcpTestClientPtr test_client =
////                                TcpTestClientPtr( new TcpTestClient( protocol_mock, CreateLogger( "client" ) ) );
////                            test_client->SetTcpPort( tcp_port );
////                            csme::platform::ThreadPtr test_client_thread = test_client->Start( );
////
////                            // server expectations
////                            EXPECT_CALL( *protocol_mock, CreateHeartbeatMessage( _ ) )
////                                .WillOnce( DoAll( SetArgReferee<0>( heartbeat_message ),
////                                                  Return( ProtocolHandlerResult::kOk ) ) )
////                                .WillOnce( Return( ProtocolHandlerResult::kErrorCloseConnection ) );
////
////                            uint16_t sleep_time = test::unit::DisableHardTimingChecks
////                                                      ? 5000
////                                                      : ( 2 * heartbeat_interval_ms ) + connection_timeout_ms;
////                            std::this_thread::sleep_for( std::chrono::milliseconds( sleep_time ) );
////
////                            REQUIRE( test_client->IsStopped( ) );
////                            // Server should have closed our connection, because it wasn't able to create a new
////                            // heartbeat message
////                            REQUIRE( test_client->LastOccurredError == asio::error::eof );
////
////                            test_client_thread->join( );
////
////                            // First clear all references on the shard_ptr which are hold by the "ECPACT_CALL"
////                            // macro but not truly be released. Afterward spend time to deconstruct all objects
////                            //in case when the CPU or server load is hight e.g. by stress tests
////                            Mock::VerifyAndClearExpectations(protocol_mock.get());
////                            std::this_thread::sleep_for(
////                            std::chrono::milliseconds( std::chrono::milliseconds (100 ) ) ) ;
////                        }
////                    }
////
////                   SHUTDOWN_DUT( );
// //               } // namespace
//
//                TEST_CASE( "libcsme/net/server/TcpTestClient" )
//                {
//                    SECTION( "NoServer" )
//                    {
//                        auto protocol_mock = std::make_shared<test::IProtocolHandlerMock>( );
//                        auto mock_guard    = MockScopeGuard( *protocol_mock );
//                        auto logger_mock   = CreateLogger( );
//
//                        EXPECT_CALL( *protocol_mock, GetMessageSeparator( ) ).Times( 1 ).WillOnce( Return( "\n" ) );
//
//                        TcpTestClientPtr test_client =
//                            TcpTestClientPtr( new TcpTestClient( protocol_mock, logger_mock ) );
//                        test_client->SetConnectTimeout( std::chrono::milliseconds( 100 ) );
//                        test_client->SetTcpPort( tcp_port );
//                        csme::platform::ThreadPtr ioctx_thread = test_client->Start( );
//                        ioctx_thread->join( );
//                        REQUIRE( test_client->LastOccurredError == asio::error::connection_refused );
//                    }
//                }
//            } // namespace
//        }     // namespace net
//    }         // namespace libcsme
//} // namespace unit
//} // namespace test
