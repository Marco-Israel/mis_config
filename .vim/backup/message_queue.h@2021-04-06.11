#ifndef LIBCSME_MSG_MESSAGE_HANDLER_BASE_H_
#define LIBCSME_MSG_MESSAGE_HANDLER_BASE_H_

#include <bits/types/struct_sched_param.h>
#include <mutex>
#include <deque>
#include <vector>
#include <atomic>
#include <condition_variable>
#include <flatbuffers/flatbuffers.h>

#include "libplatform/log/ilogger.h"
#include "libcsme/platform/shared_types.h"
#include "libcsme/net/iprotocol_handler.h"
#include "libcsme/net/imessage_sender.h"

namespace csme
{
namespace msg
{
    //   this is the centralized handler for containers. It takes care of
    //   serializing all incoming requests from all connections and creates a response
    //   container for each received container.
    //lint -save -e9174 virtual inheritance is needed here
    class MessageQueue : public virtual net::IProtocolHandler
    {
    public:
        // Creates a new message queue.
        explicit MessageQueue( const pfsw::LogPtr logger );
        ~MessageQueue( ) override;

        // Creates a thread for handling incoming requests and starts processing them, until Stop() is called.
        csme::platform::ThreadPtr Start( );
        // Stops processing of messages.
        void Stop( );
        // Checks, wether this queue is started and is able to process incoming messages
        bool IsStarted( ) const;

        net::ProtocolHandlerResult HandleIncomingMessage( const csme::platform::secure_vector<uint8_t> &message,
                                                          size_t const                                  message_size,
                                                          net::MessageSenderPtr response_sender ) override;
        std::string                GetMessageSeparator( ) override;

    protected:
        // Waits for the next message to process and processes it as long, as this thing is started. If a fatal error
        // occurred while processing the message or this handler is stopped, false is returned and the thread is ended.
        bool ProcessNextMessage( );
        bool CutOffMessageSeparator( size_t &message_size );
        // Appends the message separator to the given message
        void AppendMessageSeparator( csme::platform::secure_vector<uint8_t> &message );
        // SMS sends base64 encoded messages. This method decodes it. If decoding fails, false is returned.
        bool DecodeMessage( const csme::platform::secure_vector<uint8_t> &message,
                            size_t const                                  message_size,
                            csme::platform::secure_vector<uint8_t> &      decoded_message );
        void EncodeMessage( const uint8_t *const                    message, //lint !e9183 avoid conflicting lint rules
                            size_t const                            message_size,
                            csme::platform::secure_vector<uint8_t> &encoded_message );
        // Verifies, that the received message is in fact a valid message
        virtual bool VerifyMessage( const csme::platform::secure_vector<uint8_t> &message ) = 0;
        // Creates an actually encoded message from the (finished!) response builder, appends the separator and sends
        // it.
        void SendResponse( const net::MessageSenderPtr                           response_sender,
                           const std::shared_ptr<flatbuffers::FlatBufferBuilder> response_builder );

        /// Hook to actually process message and (eventually) return response to send
        virtual std::shared_ptr<flatbuffers::FlatBufferBuilder>
        ProcessVerifiedMessage( const csme::platform::secure_vector<uint8_t> &message ) = 0;

        std::mutex &GetMutex( );

    private:
        pfsw::LogPtr log_;
        // This mutex synchronizes all access to sessions_
        std::mutex                                                                           mutex_;
        std::atomic_bool                                                                     is_started_ = false;
        std::deque<std::pair<net::MessageSenderPtr, csme::platform::secure_vector<uint8_t>>> processing_requests_;
        std::condition_variable_any                                                          condition_;
        sched_param                                                                          schedParm_;
        uint8_t                                                                              schedPolicy_ = SCHED_RR;
    };
    //lint -restore

    using MessageHandlerPtr = std::shared_ptr<MessageQueue>;

} // namespace msg
} // namespace csme
#endif
