scriptencoding utf-8
call plug#begin('~/.vim/plugged')

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Debugging """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"LLD plugin. Fork from the real llvm project
	Plug 'gilligan/vim-lldb', { 'for': ['c', 'cpp' ] }


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Multi Language debugger
	Plug 'puremourning/vimspector', { 'for': ['c', 'cpp', 'python'] }


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Preview and Autocompleation """"""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" schow function signature in cmdline or popup
		Plug 'Shougo/echodoc.vim', { 'for': ['c', 'cpp', 'python'] }
if (&ft=='c' || &ft=='cpp' || &ft=='python')
			set cmdheight=2
			let g:echodoc#enable_at_startup = 1
			"let g:echodoc#type = 'popup'
			" To use a custom highlight for the popup window,
			" change Pmenu to your highlight group
			"highlight link EchoDocPopup Pmenu
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Completor is an asynchronous code completion framework for vim8.
"        Plug 'maralla/completor.vim'
"        Plug 'kyouryuukunn/completor-necovim'
"
"                let g:completor_python_binary = '/path/to/python/with/jedi/installed'
"                let g:completor_clang_binary = '/path/to/clang'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" not so powerful than YouCompleteMe but easier to configure and more lightway
" No LSP Protocol is required. Troubles? ':set omnifunc? completefunc?' should
" have the value 'ClangComplete'
"
"        "Pug 'justmao945/vim-clang'
"
"
"                " path to directory where library can be found
"            "let g:clang_library_path='/usr/lib/'
"            "let g:clang_library_path+='/usr/lib/libclang.so.3.9'"
"
"
"            "set conceallevel=2
"
"
"                "cursor line can also be concealed
"            "set concealcursor=vin
"
"
"               " Do some snippets magic on code placeholders
"               " like function argument, prototypes, template parameters
"            "let g:clang_snippets=1
"
"
"                " clang_complete will use conceal feature to hide placeholders
"            "let g:clang_conceal_snippets=1
"
"
"                " How to preforme snippes with clang_complete
"            "let g:clang_snippets_engine=['clang_complete', 'ultisnips']
"
"
"            "let g:clang_complete_copen=1 "open Quickfix windows on erro.
"                "Select first item in list but dont insert it. Default: 0
"
"
"            "let g:clang_complete_auto_select=0
"
"
"                "If equal to 1, automatically complete after ->, ., ::
"            "let g:clang_complete_auto=1
"
"
"                "If equal to 1, it will add optional arguments.
"            "let g:clang_complete_optional_args_in_snippets = 1
"
"
"                "add a trailing placeholder after functions
"            "let g:clang_trailing_placeholder=1
"
"
"                "Preview window will be close after a compleation
"            "let g:clang_close_after_compleation = 1
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Intellisense engine with full language server protocol support like as VSCode
"It includes stuff like showing errors, code formatting, jump to definition
""as well as completion by less configuration to let run.
"ATTENTION.: Needs an LSP server running in background.
        Plug 'neoclide/coc.nvim', {'branch': 'release', 'for': ['c', 'cpp', 'python', 'make', 'mk' ]  }
        Plug 'antoinemadec/coc-fzf', { 'for': ['c', 'cpp', 'python', 'make', 'mk'] }

if (&ft=='c' || &ft=='cpp' || &ft=='python' || &ft=='make' || &ft=='mk' )
        "ATTANTION: RUN:
        "apt-get install nodjs
        "
        "{
        "  "languageserver": {
        "    "go": {
        "      "command": "gopls",
        "      "rootPatterns": ["go.mod"],
        "      "trace.server": "verbose",
        "      "filetypes": ["go"]
        "    }
        "  }
        "}

		" Disable file with size > 1MB
		autocmd BufAdd * if getfsize(expand('<afile>')) > 1024*1024 |
				\ let b:coc_enabled=0 |
				\ ndif
        let b:coc_enabled=1
        let b:coc_suggest_disable = 0
        let b:coc_diagnostic_disable = 0

        let g:coc_global_extensions = [
            \ 'coc-json',
            \ 'coc-diagnostic',
            \ 'coc-tsserver',
            \ 'coc-snippets',
			\ 'coc-html',
			\ 'coc-phpls',
			\ 'coc-pyright',
            \ 'coc-highlight',
            \ 'coc-json',
            \ 'coc-vimtex',
            \ 'coc-python',
            \ 'coc-texlab',
            \ 'coc-ccls',
			\ 'coc-git',
            \ 'coc-spell-checker',
            \ 'coc-cspell-dicts'
        \ ]

"        "ATTANTION: Following configuration  just only copied from github .
"
"            " Some servers have issues with backup files, see #649.
"            set nobackup
"            set nowritebackup

           " Give more space for displaying messages.
            set cmdheight=2

           " Having longer updatetime (default  4000 ms = 4 s) leads to
            "noticeable delays and poor user experience.
            set updatetime=300

            " Use tab for trigger completion with characters ahead and navigate
            " NOTE: Use command ':verbose imap <tab>' to make sure tab  not
            " mapped by other plugin before putting this into your config.

	        inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
				\: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"


			inoremap <silent><expr> <TAB>
			  \ pumvisible() ? coc#_select_confirm() :
			  \ coc#expandableOrJumpable() ?
			  \ "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
			  \ <SID>check_back_space() ? "\<TAB>" :
			  \ coc#refresh()

			function! s:check_back_space() abort
			  let col = col('.') - 1
			  return !col || getline('.')[col - 1]  =~# '\s'
			endfunction


             "Use <cr> to confirm completion, `<C-g>u` means break undo chain
             "at current position. Coc only does snippet and additional edit on
             "confirm.  <cr> could be remapped by other vim plugin, try
             " `:verbose imap <CR>`.
            if exists('*complete_info')
              inoremap <expr> <cr> complete_info()["selected"] != "-1" ?
                    \ "\<C-y>" : "\<C-g>u\<CR>"
            else
              inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
            endif

            " Use `[g` and `]g` to navigate diagnostics
            nmap <silent> [g <Plug>(coc-diagnostic-prev)
            nmap <silent> ]g <Plug>(coc-diagnostic-next)

            " GoTo code navigation.
            nmap <silent> gd <Plug>(coc-definition)
            nmap <silent> gt <Plug>(coc-type-definition)
            nmap <silent> gi <Plug>(coc-implementation)
            nmap <silent> gr <Plug>(coc-references)
            nmap <silent> gu <Plug>(coc-references-used)
            nmap <silent> gt <Plug>(coc-declaration)
			vmap <silent> <leader>p  <Plug>(coc-format-selected)
			nmap <silent> <leader>p  <Plug>(coc-format-selected)

           " Use K to show documentation in preview window.
            nnoremap <silent> K :call <SID>show_documentation()<CR>

            function! s:show_documentation()
              if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
              else
                call CocAction('doHover')
              endif
            endfunction

            " Highlight the symbol and its references when holding the cursor.
            autocmd CursorHold * silent call CocActionAsync('highlight')

           augroup mygroup
             autocmd!
             " Setup formatexpr specified filetype(s).
             autocmd FileType typescript,json setl
                   \ formatexpr=CocAction('formatSelected')
             " Update signature help on jump placeholder.
             autocmd User CocJumpPlaceholder call
                   \ CocActionAsync('showSignatureHelp')
			augroup end

			" Try first quickfix action for diagnostics on the current line.
			nmap <leader>qf  <Plug>(coc-fix-current)

               "Symbol rename everywhere
			nmap <leader>rn <Plug>(coc-rename)
			nmap <leader>rf <Plug>(coc-refactor)

            " Formatting selected code.
			xmap <leader>fc  <Plug>(coc-format-selected)
			nmap <leader>fc  <Plug>(coc-format-selected)
			vmap <leader>fc  <Plug>(coc-format-selected)
			vmap <leader>p  <Plug>(coc-format-selected)
			nmap <leader>p  <Plug>(coc-format-selected)

           " Map function and class text objects
           " NOTE: Requires 'textDocument.documentSymbol' support from the
           " language server.
           xmap <leader>if <Plug>(coc-funcobj-i)
           omap <leader>if <Plug>(coc-funcobj-i)
           xmap <leader>af <Plug>(coc-funcobj-a)
           omap <leader>af <Plug>(coc-funcobj-a)
           xmap <leader>ic <Plug>(coc-classobj-i)
           omap <leader>ic <Plug>(coc-classobj-i)
           xmap <leader>ac <Plug>(coc-classobj-a)
           omap <leader>ac <Plug>(coc-classobj-a)
	  	   nmap <leader>[r <Plug>(coc-range-select)
	  	   xmap <leader>[r <Plug>(coc-range-select)
	  	   vmap <leader>[r <Plug>(coc-range-select)
	  	   nmap <leader>]r <Plug>(coc-range-select-backward)
	  	   xmap <leader>]r <Plug>(coc-range-select-backward)
	  	   vmap <leader>]r <Plug>(coc-range-select-backward)


            " Applying codeAction to the selected region.
            " Example: `<leader>aap` for current paragraph
			nmap <leader> ca <Plug>(coc-codeaction)
			nmap <leader> cs <Plug>(coc-codeaction-selected)
			vmap <leader> cs <Plug>(coc-codeaction-selected)
			nmap <leader> <leader> ca <Plug>(coc-codeaction-line)


			"Show and navigate diagnostic message of current position
			nmap <leader>id <Plug>(coc-diagnostic-info)
			nmap [d <Plug>(coc-diagnostic-next)
			nmap ]d <Plug>(coc-diagnostic-prev)
			nmap [[d <Plug>(coc-diagonostic-next-error)
			nmap ]]d <Plug>(coc-diagnostic-prev-error)

            " Use CTRL-S for selections ranges.
            " Requires 'textDocument/selectionRange' support of LS, ex:
            " coc-tsserver
"            nmap <silent> <C-s> <Plug>(coc-range-select)
"            xmap <silent> <C-s> <Plug>(coc-range-select)

            " Add `:Format` command to format current buffer.
            command! -nargs=0 Format :call CocAction('format')

            " Add `:Fold` command to fold current buffer.
            command! -nargs=? Fold :call     CocAction('fold', <f-args>)

            " Add `:OR` command for organize imports of the current buffer.
            command! -nargs=0 OR   :call     CocAction('runCommand',
                    \ 'editor.action.organizeImport')

			" Run codeAction for the current file
            command! -nargs=0 CocDigInfo :call CocAction('diagnosticInfo')
            command! -nargs=0 CocSignatur :call CocAction('showSignatureHelp')
            command! -nargs=0 CocCodeActionOnFile :call CocAction('codeActions')
            command! -nargs=0 CocColorPicker :call CocAction('pickColor')
            command! -nargs=0 CocColorPresentation :call CocAction('colorPresentation')

            " Add (Neo)Vim's native statusline support.
            " NOTE: Please see `:h coc-status` for integrations with external
            " plugins that
            " provide custom statusline: lightline.vim, vim-airline.
            set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

            " Mappings using CoCList:
			" Open refector

            " Show all diagnostics.
            nnoremap <silent> <space>d  :<C-u>CocList diagnostics<cr>
            " Manage extensions.
            nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
            " Show commands.
            nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
            " Find symbol of current document.
            nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
            " Search workspace symbols.
            nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
            " Do default action for next item.
            nnoremap <silent> <space>j  :<C-u>CocNext<CR>
            " Do default action for previous item.
            nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
            " Resume latest coc list.
            nnoremap <silent> <space>p  :<C-u>CocListResume<CR>
			" Show diagnostic message of corrent poxition
			nnoremap <silent> <C-space> <Plug>(coc-diagnostic-info)
			" Open CodeLeans for the current line
			nnoremap <silent> <leader><space> <Plug>(coc-codelens-action)
                " Snipping depending
                " Use <C-l> for trigger snippet expand.
            imap <C-l> <Plug>(coc-snippets-expand)

                " Use <C-j> for select text for visual placeholder of snippet.
            vmap <C-j> <Plug>(coc-snippets-select)

                " Use <C-j> for jump to next placeholder
            let g:coc_snippet_next = '<c-j>'

                " Use <C-k> for jump to previous placeholder
            let g:coc_snippet_prev = '<c-k>'

                " Use <C-j> for both expand and jump (expand higher priority.)
            imap <C-j> <Plug>(coc-snippets-expand-jump)

				" Jump locations when the |CocLocationsChange| autocmd is fired.
			" let g:coc_jump_locations=1

				"Kill Coc.vim when Vim gets close
			autocmd VimLeavePre * if get(g:, 'coc_process_pid', 0)
				\	| call system('kill -9 '.g:coc_process_pid) | endif

				" Disable compleation sources for filetyps
			let g:coc_sources_disable_map = {}

			" Map filetypes so that server could handel tham
			"let g:coc_filetype_map = {
			"	\ 'html.swig': 'html',
			"	\ 'wxss': 'css',
			"	\ }

			"URI replacment, if an LSP requires code to adhere to a
			"particular directory structure.
			"let g:coc_uri_prefix_replace_patterns = {'/Users': '/home'}

				" Add keyword characters
			"let b:coc_additional_keywords = [".","-","->"]

			" Get Hoover function information
			autocmd User CocJumpPlaceholder call
				\ CocActionAsync('showSignatureHelp')


			function! StatusDiagnostic() abort
			  let info = get(b:, 'coc_diagnostic_info', {})
			  if empty(info) | return '' | endif
			  let msgs = []
			  if get(info, 'error', 0)
			    call add(msgs, 'E' . info['error'])
			  endif
			  if get(info, 'warning', 0)
			    call add(msgs, 'W' . info['warning'])
			  endif
			  return join(msgs, ' ') . ' ' . get(g:, 'coc_status', '')
			endfunction
			set statusline^=%{StatusDiagnostic()}

else
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Minimalist autocompletion of chained (fallback). It does no caching, no
" asynchronous computation, no intelligent guessing. It just makes use of core
" Vim features. completion, hereby several completion methods are attempted
" one after another " until a result is returned. when you press <tab>/<s-tab>
			Plug 'https://github.com/lifepillar/vim-mucomplete'

				let g:snipMate = {}
				let g:snipMate['no_match_completion_feedkeys_chars'] = ''

				inoremap <plug>MyEnter <cr>
				imap <silent> <expr> <plug>MyCR (pumvisible()
				    \ ? "\<c-y>\<plug>snipMateTrigger"
				    \ : "\<plug>MyEnter")
				imap <cr> <plug>MyCR

                let g:mucomplete#enable_auto_at_startup = 0
                let g:mucomplete#completion_delay = 0

                    "Example Chain:
                " let g:mucomplete#user_mappings = { 'sqla' : "\<c-c>a" }
                " let g:mucomplete#chains = { 'sql' : ['file', 'sqla', 'keyn'] }

"
"                    " SEE |KEY-VALUES|
              	let g:mucomplete#chains = {
	   				\ 'default' : [ 'spel', 'uspl', 'file', 'path', 'keyn',
					\				'keyp', 'nsnp', 'defs', 'c-n', 'c-p',
					\				'dict', 'thes', 'incl' ],
	   				\ 'vim'     : ['path', 'cmd', 'keyn'],
                    \ 'tex'     : [ 'snip', 'defs', 'tags', 'spel', 'uspl',
                                \ 'dict', 'file', 'path', 'list', 'user',
                                \ 'omni', 'thes', 'incl','c-n', 'c-p'],
	   				 \ }
    " |KEY-VALUES|
	"
	"c-n" : keywords in 'complete' (search forwards);        |i_CTRL-N|
	"c-p" : keywords in 'complete' (search backwards);       |i_CTRL-P|
	"cmd" : Vim command line;                                |i_CTRL-X_CTRL-V|
	"defs": definitions or macros;                           |i_CTRL-X_CTRL-D|
	"dict": keywords in 'dictionary';                        |i_CTRL-X_CTRL-K|
	"file": file names;                                      |i_CTRL-X_CTRL-F|
	"incl": keywords in the current and included files;      |i_CTRL-X_CTRL-I|
	"keyn": keywords in the current file (search forwards);  |i_CTRL-X_CTRL-N|
	"keyp": keywords in the current file (search backwards); |i_CTRL-X_CTRL-P|
	"line": whole lines;                                     |i_CTRL-X_CTRL-L|
	"omni": omni completion ('omnifunc');                    |i_CTRL-X_CTRL-O|
	"spel": spelling suggestions;                            |i_CTRL-X_s|
	"tags": tags;                                            |i_CTRL-X_CTRL-]|
	"thes": keywords in 'thesaurus';                         |i_CTRL-X_CTRL-T|
	"user": user defined completion ('completefunc').        |i_CTRL-X_CTRL-U|
	"
	"Besides, MUcomplete implements its own alternative file completion and
	"spelling suggestions:
	"
	"path": file names (MUcomplete's implementation).
	"uspl": spelling suggestions (MUcomplete's implementation).
	"
	"You may also use your own list of words:
	"
	"list": complete words from |b:mucomplete_wordlist| or |g:mucomplete#wordlist|.
	"
	"MUcomplete also supports Neosnippet, SnipMate and UltiSnips:
	"
	"nsnp": Neosnippet snippets.
	"snip": SnipMate snippets.
	"ulti": UltiSnips snippets.


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Use tab key for all sorts of completion. Maybe works not with Snipmate?
"       Plug 'https://github.com/ajh17/vimcompletesme'
"        Plug 'https://github.com/ervandew/supertab'
"
"
"                "Completion to be preformed. Frst default, second depends on the
"                "word compleation should be preformed. third onifunc
"            "let g:SuperTabDefaultCompletionType = '<c-p>'
"             let g:SuperTabDefaultCompletionType = 'context'
"            "let g:SuperTabDefaultCompletionType = '<c-x><c-o>'
"
"
"                 "Fallback if DefaultCompeation set to contex
"            let g:SuperTabContextDefaultCompletionType = '<c-x><c-o>'
"
"
"                "Enable longest menu option if the menu is configured this way
"            let g:SuperTabLongestEnhanced = 1
"
"
"                "Select the first entry in a longest menu list by default
"            let g:SuperTabLongestHighlight = 1
"
"
"                "Attempt to close vim's completion preview window to
"            let g:SuperTabClosePreviewOnPopupClose = 1
"
"
"                " List of functions to preforme in order for every compleation
"            "let g:SuperTabCompletionContexts  =  ['s:ContextText']
"
"
"               "Chain one compleation functions specific for plugins.
"               "ATTANTION: This functions needs to bee defined first !
"           " augroup SUPERTAB
"           " if has('autocmd') && exists('+omnifunc')
"           "     autocmd FileType *
"           "        \ if &omnifunc != '' |
"           "         \   call
""            let g:UltiSnipsExpandTrigger="<tab>"
""            let g:UltiSnipsJumpForwardTrigger="<c-b>"
""            let g:UltiSnipsJumpBackwardTrigger="<c-z>"
""            let g:UltiSnipsEditSplit="vertical"
"
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Bash completion accessible within vim
"		Plug 'rantasub/vim-bash-completion'




"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Provides an extensible and asynchronous completion framework for neovim/Vim8
"        Plug 'Shougo/deoplete.nvim'
"        Plug 'deoplete-plugins/deoplete-clang'
"        Plug 'roxma/nvim-yarp'
"        Plug 'roxma/vim-hug-neovim-rpc'
"        Plug 'Shougo/neosnippet.vim'
" 		 Plug 'deoplete-jedi'
"
"            let g:deoplete#enable_at_startup = 1
"
"
"        "ATTANTION: You need to install python > 3.6.1
"        "   pip3 install --user pynvim
"
"        "ATTANTION: for vimtex.vim only:
"          "call deoplete#custom#var('omni', 'input_patterns', {
"          "        \ 'tex': g:vimtex#re#deoplete
"          "        \})
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"It provides an omnifunc compleat function in C/C++ files by required ctags db.
" Sould be included in vim already: :h ft-syntax-omni
"        Plug 'https://github.com/vim-scripts/OmniCppComplete'
"        Plug 'vim-scripts/SyntaxComplete'
"
"            let OmniCpp_NamespaceSearch = 2  "Search in Include IF PATH is set.
"                                             "Does not work for C.
"            let OmniCpp_DisplayMode = 1      "Show all member of all scops.
"            let OmniCpp_ShowScopeInAbbr = 0  "this  defaut. Dont show scope.
"            let OmniCpp_ShowPrototypeInAbbr = 1
"            let OmniCpp_ShowAccess = 1
"            let OmniCpp_MayCompleteDot = 1
"            let OmniCpp_MayCompleteArrow = 1
"            let OmniCpp_MayCompleteScope = 1
"            m-scripts/SyntaxComplete'let OmniCpp_SelectFirstItem = 2
"            let OmniCpp_GlobalScopeSearch = 1
"            let OmniCpp_LocalSearchDecl = 1     "search variables not only in
"                                                "first line of enclusing braces
"            let OmniCpp_DefaultNamespaces = ['std', '_GLIBCXX_STD']
"
"               "automatically open and close
"            augroup OMNI
"            autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
"            autocmd InsertLeave * if pumvisible() == 0|pclose|endif
"
"
"               "Set compleation option default to syntax compleation based on
"               "keywords and change it for C respectively for C++.
"            if has("autocmd") && exists("+omnifunc")
"        	autocmd Filetype *
"        		    \	if &omnifunc == "" |
"        		    \		setlocal omnifunc=syntaxcomplete#Complete |
"        		    \	endif
"
"                    autocmd BufNewFile,BufRead,BufEnter *.c,*.h
"                                \ set omnifunc=ccomplete#Complete
"                    autocmd BufNewFile,BufRead,BufEnter *.cpp,*.hpp
"                                \ set omnifunc+=omni#cpp#complete#Main
"            endif
"            augroup END
"
"                "Mappings that feels a little more like IDE completion menu
"            "inoremap <expr> <Esc>      pumvisible() ? "\<C-e>" : "\<Esc>"
"            "inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
"            "inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
"            "inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
"            "inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>"
"            "                            \:"\<PageDown>"
"            "inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>"
"                                        \:\<PageUp>"
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Snipped plugin and databases in pre vim language.
        Plug 'MarcWeber/vim-addon-mw-utils'
        Plug 'tomtom/tlib_vim'
        Plug 'garbas/vim-snipmate'
        Plug 'honza/vim-snippets'

        let g:snipMate = { 'snippet_version' : 1 }


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Automatically opens completion pop-up menu till writing
"        Plug 'https://github.com/vim-scripts/AutoComplPop'
"
"                "enable auto-popup with snipMate add the following like
"                " described in "https://githubcom/vim-scripts/AutoComplPop
"            let g:acp_behaviorSnipmateLength=1
"
"            "  fun! GetSnipsInCurrentScope()
"            "    let snips = {}
"            "    for scope in [bufnr('%')] + split(&ft, '\.') + ['_']
"            "      call extend(snips, get(s:snippets, scope, {}), 'keep')
"            "      call extend(snips, get(s:multi_snips, scope, {}), 'keep')
"            "    endfor
"            "    return snips
"            "  endf


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Provides functions to easy preview/open files. Maybe also done by FZF?
"        Plug 'skywind3000/vim-preview'
"
"        augroup PREVIEW
"        noremap <m-u> :PreviewScroll -1<cr>
"        noremap <m-d> :PreviewScroll +1<cr>
"        inoremap <m-u> <c-\><c-o>:PreviewScroll -1<cr>
"        inoremap <m-d> <c-\><c-o>:PreviewScroll +1<cr>
"        autocmd FileType qf nnoremap <silent><buffer> p :PreviewQuickfix<cr>
"        autocmd FileType qf nnoremap <silent><buffer> P :PreviewClose<cr>
"        noremap <F4> :PreviewSignature!<cr>
"        inoremap <F4> <c-\><c-o>:PreviewSignature!<cr>
"        augroup END


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Opening file from QUICKFIX in a preview Window instead of a current buffer.
        Plug 'ronakg/quickr-preview.vim'   ", { 'for': ['c', 'cpp' ] }

if (&ft=='c' || &ft=='cpp')
                "Tun default keys off
            let g:quickr_preview_keymaps = 0

                "Define custom key mappings
             nmap <space>* <plug>(quickr_preview) "default
            "nmap <leader>q <plug>(quickr_preview_qf_close)

                "Configuring the preview window position: left,right,above,below
            let g:quickr_preview_position = 'popup'

                "Configuring the preview window size
            let g:quickr_preview_size = '5' "Default =0 = half of the screen

                "Configuring the preview window highlighting
            let g:quickr_preview_line_hl = 'Search'

                "Configuring the preview window with :set local  options
            let g:quickr_preview_options ='nonumber norelativenumber nofoldenable'

                "Auto-open preview window
            let g:quickr_preview_on_cursor = 0

                "Auto-close quickfix on enter
            let g:quickr_preview_exit_on_enter = 1
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Insert or delete brackets, parens, quotes in pair. Highly configurable
"    "Plug 'https://github.com/jiangmiao/auto-pairs'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Surrounds and object by motions with eg "" or ()
        Plug 'tpope/vim-surround'

        "Example: Define your own keys which should trigger a surround by e.g.:
        "let g:surround_<ASCII_CHAR_of_trigger>
        "let g:surround_{char2nr("d")} ="<div\1id: \r..*\r id=\"&\"\1>\r</div>"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ATTANTION: OVERWRITES <UP> <DOWN> currently.
""Enables tab completion in search mode  Not configuration needed/possible.
"        Plug 'https://github.com/vim-scripts/SearchComplete'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple clears the search pattern after moving around,
        Plug 'https://github.com/haya14busa/is.vim'

        "ATTATION: Activate also mapings for the astrix.vim pugin if used.

        "ATTATION: Activate also mapings for the anzu.vim pugin if used.


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Insert a date, time ... by key
"        Plug 'https://github.com/tpope/vim-speeddating'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" SYNTAX check, highlight, LINT tool formatter """"""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Asynchronous Lint Engine with syntax check, autocompletion, etc like syntactic

        Plug 'w0rp/ale', { 'for': ['c', 'cpp', 'python'] }


if (&ft=='c' || &ft=='cpp' || &ft=='python' || &ft=='make' || &ft=='mk' )
            augroup ASYNCCOMPLEAT
            autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
            augroup END

            map <silent> <buffer>[d <Plug>(ale_previous_wrap)
            map <silent> <buffer>]d <Plug>(ale_next_wrap)

			nmap <silent> <space>gd :ALEGoToDefinition<cr>
			nmap <silent> <space>gg :ALEGoToTypeDefinition<cr>
			nmap <silent> <space>gr :ALEFindReferences<cr>
			nmap <silent> <space>gs :ALESymbolSearch<cr>
			nmap <silent> <space>gh :ALEHover<cr>
			nmap <silent> <space>gn :ALERename<cr>
			nmap <silent> <space>ga :ALECodeAction<cr>


			highlight ALEErrorSign ctermfg=red
			highlight ALEWarningSign ctermfg=red
			let g:ale_sign_error = '>>'
			let g:ale_sign_warning = '>>'
            let g:ale_enabled=0
            let g:ale_completion_enabled = 0
            let g:ale_completion_delay = 1000
            let g:ale_close_preview_on_insert = 1
            let g:ale_completion_tsserver_autoimport = 1
            let g:ale_cursor_detail = 0
            let g:ale_echo_msg_error_str = 'ALE Error'
            let g:ale_echo_msg_info_str = 'ALE Info'
            let g:ale_echo_msg_warning_str = 'ALE Warning'
            let g:ale_echo_msg_log_str = 'ALE Log'
            let g:ale_echo_msg_format = '%severity:  %code:%%s'
            let g:ale_fix_on_save = 1
            let g:ale_fix_on_save_ignore = { }
            let g:ale_lint_on_text_changed = 'never'
            let g:ale_lint_on_insert_leave = 0
            let g:ale_lint_delay = 1000
            let g:ale_lsp_show_message_severity = 'info'
            let g:ale_set_signs =  has('signs')
            let g:ale_max_signs =  -1
            let g:ale_rename_tsserver_find_in_comments = 1
            let g:ale_rename_tsserver_find_in_strings = 0
            let g:ale_set_highlights = has('syntax')
            let g:ale_set_quickfix = 0
            let g:ale_sign_highlight_linenrs = 1    "Highlight on number column
            let g:ale_warn_about_trailing_blank_lines = 1
            let g:ale_warn_about_trailing_whitespace = 1
            let g:ale_completion_autoimport=1
            let g:ale_completion_tsserver_remove_warnings=0
            let g:ale_update_tagstack=1
            let g:ale_hover_cursor=0
            let g:ale_set_balloons=1
            let g:ale_popup_menu_enabled=has('gui_running')
            let g:ale_list_vertical=11
            let g:ale_warn_about_trailing_whitespace=1
			let g:ale_echo_msg_format='%code: %%s  - %severity% : %severity%'
			let g:ale_exclude_highlights= []
			let g:ale_open_list = 0
			"let g:ale_list_window_size = somesize
				augroup CloseLoclistWindowGroup
					"Close the list window when the buffer is or gets closed
  				  autocmd!
  				  autocmd QuitPre * if empty(&buftype) | lclose | endif
  				augroup END
			let g:le_rename_tsserver_find_in_comments = 1

		"nmap <leader>b	<Plug>(ale_documentation)
		"	<Plug>(ale_go_to_definition)`           - `:ALEGoToDefinition`
  		"	<Plug>(ale_go_to_definition_in_tab)`    - `:ALEGoToDefinition -tab`
  		nmap <leader>b	<Plug>(ale_go_to_definition_in_split)`  - `:ALEGoToDefinition -split`
  		"	<Plug>(ale_go_to_definition_in_vsplit)` - `:ALEGoToDefinition -vsplit`

			nmap <space>K :ALEDocumentation <cr>
			nmap <leader><space>s :ALEFindReferences -vsplit <cr>
			nmap <leader><space>f: ALEFix <cr>
			nmap <space>gd :ALEGoToDefinition -split<cr>
			nmap <space>gt :ALEGoToTypeDefinition -split<cr>
			nmap <space>gh :ALEHover <cr>
			nmap <space>rn :ALERename <cr>
			nmap <leader><space>gs ALESymbolSearch <cr>
			nmap  <space>qf :ALEFixSuggest <cr>
			nmap <space>gj :ALEPreviousWrap <cr>
			nmap <space>gk :ALENextWrap <cr>
			nmap <leader>rp :ALERepeatSelection <cr>
			nmap <space>rp :ALECodeAction <cr>
"			:ALEInfoToClipboard <cr>
"			:ALEPrevious <cr>
"			ALENext <cr>
"			:ALEFirst <cr>
"			:ALELast <cr>
			 "let g:ale_c_project_filenames = ['.git/HEAD', 'configure', 'Makefile', 'CMakeLists.txt', 'compile_flags.txt']


			"ccls
			 let  g:ale_c_ccls_init_options = {
			    \   'cacheDirectory': '/tmp/ccls-cache',
			    \   'cacheFormat': 'binary',
			    \   'diagnostics': {
			    \     'onOpen': 0,
			    \     'opChange': 1000,
			    \   },
			    \ }

			let g:ale_c_cppcheck_executable = 'cppcheck'
			let g:ale_c_cppcheck_options =  '--enable=style'


"            let g:ale_fixers  = {
"                \ 'c': ['astyle','clang-format', 'clangtidy',
"					\ 'remove_trailing_lines', 'trim_whitespace','uncrustify' ],
"                \ 'cpp': ['astyle','clang-format', 'clangtidy',
"					\ 'remove_trailing_lines', 'trim_whitespace','uncrustify' ],
"                \ 'tex': ['all'],
"                \ 'latex': ['all'],
"                \ 'python': ['all']
"            \ }
			let g:ale_linters = {
                \ 'c': [ 'clangd', 'cppcheck', 'cpplint', 'cquery', 'flawfinder'],
                \ 'cpp': [ 'clangd', 'cppcheck', 'cpplint', 'cquery', 'flawfinder'],
                \ 'tex': ['all'],
                \ 'latex': ['all'],
                \ 'python': ['all']
            \ }

"              let g:ale_completion_symbols = {
"              \ 'text': '',
"              \ 'method': '',
"              \ 'function': '',
"              \ 'constructor': '',
"              \ 'field': '',
"              \ 'variable': '',
"              \ 'class': '',
"              \ 'interface': '',
"              \ 'module': '',
"              \ 'property': '',
"              \ 'unit': 'unit',
"              \ 'value': 'val',
"              \ 'enum': '',
"              \ 'keyword': 'keyword',
"              \ 'snippet': '',
"              \ 'color': 'color',
"              \ 'file': '',
"              \ 'reference': 'ref',
"              \ 'folder': '',
"              \ 'enum member': '',
"              \ 'constant': '',
"              \ 'struct': '',
"              \ 'event': 'event',
"              \ 'operator': '',
"              \ 'type_parameter': 'type param',
"              \ '<default>': 'v'
"              \ }
"
            augroup ALE
            if has('autocmd') && exists('+omnifunc')
                autocmd Filetype *
                    \ if &omnifunc ==""
                    \ || &omnifunc =="syntaxcomplete#Complete" |
                    \ setlocal omnifunc =ale#completion#OmniFunc |
                    \ endif
            endif
            augroup END
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Powerful syntax check tool for a lot of languages. Runs NOT asynchrony like ale
"       Plug 'https://github.com/vim-syntastic/syntastic'
"
"           let g:syntastic_c_checkers = ['clang', 'gcc', 'make']
"           let g:syntastic_clang_check_config_file
"           let g:syntastic_c_compiler = 'clang'
"           let g:syntastic_c_compiler_options = ' -std=c11 -stdlib=libc'
"           let g:syntastic_c_check_header = 1
"           set statusline+=%#warningmsg#
"           set statusline+=%{SyntasticStatuslineFlag()}
"           set statusline+=%*
"           let g:syntastic_always_populate_loc_list = 1
"           let g:syntastic_auto_loc_list = 1
"           let g:syntastic_check_on_open = 0
"           let g:syntastic_enable_balloons = 1
"           let g:syntastic_check_on_wq = 0
"           "let g:syntastic_auto_jump = 1
"           "let g:syntastic_c_include_dirs = [ '/<your-path>' ]
"           let g:syntastic_mode_map = {
"               \ "mode": "passive",
"               \ "active_filetypes": ["c", "h"],
"               \ "passive_filetypes": [""] }




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple and easy plugin to displays/toggle parentheses in different colors.
"To define different colores langeuage dependent, you need an othter plugin
"             Plug 'https://github.com/kien/rainbow_parentheses.vim'
"
"            let g:rbpt_colorpairs = [
"                \ ['brown',       'RoyalBlue3'],
"                \ ['Darkblue',    'SeaGreen3'],
"                \ ['darkgray',    'DarkOrchid3'],
"                \ ['darkgreen',   'firebrick3'],
"                \ ['darkcyan',    'RoyalBlue3'],
"                \ ['darkred',     'SeaGreen3'],
"                \ ['darkmagenta', 'DarkOrchid3'],
"                \ ['brown',       'firebrick3'],
"                \ ['gray',        'RoyalBlue3'],
"                \ ['black',       'SeaGreen3'],
"                \ ['darkmagenta', 'DarkOrchid3'],
"                \ ['Darkblue',    'firebrick3'],
"                \ ['darkgreen',   'RoyalBlue3'],
"                \ ['darkcyan',    'SeaGreen3'],
"                \ ['darkred',     'DarkOrchid3'],
"                \ ['red',         'firebrick3'],
"                \ ]
"
"                let g:rbpt_max = 16
"                let g:rbpt_loadcmd_toggle = 0
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Implants clang-format.py featurs in vim lang. It needs to configured inside
"vim with same options like normal clang-format.py.
"        Plug 'https://github.com/rhysd/vim-clang-format'
"
"            "Execute clang-format -dump-config command for more options..
"            let g:clang_format#style_options = {
"                \ "AccessModifierOffset" : -4,
"                \ "AllowShortIfStatementsOnASingleLine" : "true",
"                \ "AlwaysBreakTemplateDeclarations" : "true",
"                \ "Standard" : "C++11",
"                \ "BreakBeforeBraces" : "Stroustrup"}
"



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" COMMENT handling  """""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple comment out some lines by using <N>gcc or gcgc, ..
        Plug 'https://github.com/tpope/vim-commentary', { 'for': ['c', 'cpp', 'python'] }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" ALIGNMENT handling  """""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Align at different places by using vipga=  gaip = commands.
        Plug 'junegunn/vim-easy-align', { 'for': ['c', 'cpp', 'python'] }

if (&ft=='c' || &ft=='cpp' || &ft=='python' )

            " Start interactive EasyAlign in visual mode (e.g. vipga)
            xmap ga <Plug>(EasyAlign)

            " Start interactive EasyAlign for a motion/text object (e.g. gaip)
            nmap ga <Plug>(EasyAlign)
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple align text blocks by :Tabularize command
        Plug 'https://github.com/godlygeek/tabular'




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" MOVEMENT and MOTIONS """"""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Faster moving with leader-s
"        "Plug 'https://github.com/easymotion/vim-easymotion'
"        "Plug 'https://github.com/haya14busa/incsearch.vim'
"        "Plug 'https://github.com/haya14busa/incsearch-fuzzy.vim'
"        "Plug 'https://github.com/haya14busa/incsearch-easymotion.vim'
"
"
"            "map <Leader> <Plug>(easymotion-prefix)
"            "
"            " <Leader>f{char} to move to {char}
"            map  <Leader>f <Plug>(easymotion-bd-f)
"            nmap <Leader>f <Plug>(easymotion-overwin-f)
"
"            " s{char}{char} to move to {char}{char}
"            nmap s <Plug>(easymotion-overwin-f2)
"
"            " Move to line
"            map <Leader>L <Plug>(easymotion-bd-jk)
"            nmap <Leader>L <Plug>(easymotion-overwin-line)
"
"            " Move to word
"            map  <Leader>w <Plug>(easymotion-bd-w)
"            nmap <Leader>w <Plug>(easymotion-overwin-w)
"
"
"
"            You can use other keymappings like <C-l> instead of <CR> if you
"            want to use these mappings as default search and sometimes want
"            to move cursor with EasyMotion.
"            function! s:incsearch_config(...) abort
"              return incsearch#util#deepextend(deepcopy({
"              \  'modules':[incsearch#config#easymotion#module({'overwin':1})],
"              \  'keymap': {
"              \    "\<CR>": '<Over>(easymotion)'
"              \  },
"              \  'is_expr': 0
"              \ }), get(a:, 1, {}))
"            endfunction
"
"            noremap <silent><expr> /  incsearch#go(<SID>incsearch_config())
"            noremap <silent><expr> ?
"                       \ incsearch#go(<SID>incsearch_config({'command': '?'}))
"            noremap <silent><expr> g/
"                       \ incsearch#go(<SID>incsearch_config({'is_stay': 1}))
"
"
"            function! s:config_easyfuzzymotion(...) abort
"              return extend(copy({
"              \  'converters': [incsearch#config#fuzzyword#converter()],
"              \  'modules':[incsearch#config#easymotion#module({'overwin':1})],
"              \  'keymap': {"\<CR>": '<Over>(easymotion)'},
"              \  'is_expr': 0,
"              \  'is_stay': 1
"              \ }), get(a:, 1, {}))
"            endfunction
"
"            noremap <silent><expr> <Space>/
"                           \ incsearch#go(<SID>config_easyfuzzymotion())
"
"            " Require tpope/vim-repeat to enable dot repeat support
"            " Jump to anywhere with only `s{char}{target}`
"            " `s<CR>` repeat last find motion.
"            nmap s <Plug>(easymotion-s)
"            " Bidirectional & within line 't' motion
"            "omap t <Plug>(easymotion-bd-tl)
"            " Use uppercase target labels and type as a lower case
"            let g:EasyMotion_use_upper = 1
"             " type `l` and match `l`&`L`
"            let g:EasyMotion_smartcase = 1
"            " Smartsign (type `3` and match `3`&`#`)
"            let g:EasyMotion_use_smartsign_us = 1
"
"
"            "let g:EasyMotion_do_mapping = 0 " Disable default mappings
"
"            " Jump to anywhere you want with minimal (on keybinding) keystrokes
"
"            nmap s <Plug>(easymotion-overwin-f)
"            " or
"            " `s{char}{char}{label}`
"            " Need one more keystroke, but on average, it may be smarter
"            nmap s <Plug>(easymotion-overwin-f2)
"
"            " Turn on case-insensitive feature
"            "let g:EasyMotion_smartcase = 1
"
"            " JK motions: Line motions
"            map <Leader>j <Plug>(easymotion-j)
"            map <Leader>k <Plug>(easymotion-k)
"            map <Leader>l <Plug>(easymotion-lineforward)
"            map <Leader>j <Plug>(easymotion-j)
"            map <Leader>k <Plug>(easymotion-k)
"            map <Leader>h <Plug>(easymotion-linebackward)
"
"            map  / <Plug>(easymotion-sn)
"            omap / <Plug>(easymotion-tn)
"
"             Eeasy Motions plugins
"             These `n` & `N` mappings are options. You do not have to
"             map `n` & `N` to EasyMotion. Without these mappings, `n` & `N`
"             works fine. (These mappings just provide different highlight
"             method and have some other features)
"            map  <Leader><Leader>n <Plug>(easymotion-next)
"            map  <Leader><Leader>N <Plug>(easymotion-prev)
"            nmap <Leader><Leader>s <Plug>(easymotion-s2)
"            nmap <Leader><Leader>t <Plug>(easymotion-t2)
"
"
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Place, toggle and display MARKS.
        Plug 'https://github.com/kshenoy/vim-signature'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Toggle a markbar and display MARKS locations in a split.
        Plug 'https://github.com/Yilin-Yang/vim-markbar'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Toggle between source and header by simple command :A
        Plug 'https://github.com/vim-scripts/a.vim', { 'for': ['c', 'cpp' ] }


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Like easy motions / or ? but seems to be more and faster and without hiding.
"Simple go to to text locations by only searching some ess patterns. Uses s key.
        Plug 'justinmk/vim-sneak'

                "Hide the matches like easy motion does if set to 1
            let g:sneak#label = 0

            "ATTATION: IF 'repmo.vim' vim  enabed (below) the mappings
            "for this vim-sneak plugin must also activated there!


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Executes (parts of) current buffer as program from inside vim
" e.g. ':QuickRun bash' or ':3,6QuickRun python'
        Plug 'https://github.com/thinca/vim-quickrun', { 'for': ['sh', 'bash'] }
if (&ft=='bash' || &ft=='sh')
		" Set shortcut keys to  close
	 	nnoremap <Leader>rq :<C-u>bw! quickrun\ output<CR>
		" Set shortcut keys to run
		for [key, com] in items({
		\   '<Leader>qx' : '>:',
		\   '<Leader>qp' : '>!',
		\   '<Leader>qw' : '>',
		\   '<Leader>qr' : '>>',
		\ })
			execute 'nnoremap <silent>' key ':QuickRun' com '-mode n<CR>'
			execute 'vnoremap <silent>' key ':QuickRun' com '-mode v<CR>'
		endfor
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Select howl comments by dealing a 'comment textobject' using the plugin below.
"        Plug 'glts/vim-textobj-comment'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"A lot of different mappings like [q ]q quickfixnavication.
        Plug 'https://github.com/tpope/vim-unimpaired'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Adds Commands to execute Write, Move, ... direct from command line
        Plug 'tpope/vim-eunuch'
        Plug 'tpope/vim-scriptease'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Defines more (movements like 'cin' (target objects) working with the . Command
        Plug 'https://github.com/wellle/targets.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"This plugin defines a new text object, based on indentation levels, include
"regions surrounded by various types of brackets and various parts of language
        Plug 'michaeljsmith/vim-indent-object'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Extended % matching for HTML, LaTeX, vimscrips and many other languages
"        Plug 'andymass/vim-matchup'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" EXPLORERS """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple, stupid and fast tab-bar for VIM. Names of opened buffer are shortened
"and shows on the top row of window.
"        Plug 'https://github.com/drmingdrmer/vim-tabbar'
"
"            "Three high light settings in color scheme file for this plugin
"            "hi TabLineFill cterm=none ctermfg=grey  ctermbg=cyan
"            "hi TabLine     cterm=none ctermfg=white ctermbg=cyan
"            "hi TabLineSel  cterm=none ctermfg=black ctermbg=white
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple open buffers in split/vertical mode by leader key
        Plug 'https://github.com/jlanzarotta/bufexplorer'
            noremap <F12> :BufExplorerVerticalSplit<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"show buffers in status line with moving around
        "Plug 'https://github.com/vim-scripts/buftabs'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"shows buffers in top titelbar. Provides navigation
"        Plug 'https://github.com/bagrat/vim-buffet'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Defines something like a 'projects' in .vimrc
"        Plug 'amiorin/vim-project'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Opens ranger file explorer from inside vim
"        "Plug 'francoiscabrol/ranger.vim'
"
"                "default ranger commands like console.
"            let g:ranger_command_overrider='ranger --cmd "set show_hidden=true"'
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"vifm Filemanager integration
 "       Plug 'vifm/vifm.vim'
        "Plug 'vimoxide/vim-vifmd'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple file explorer in splitbar
        Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
        Plug 'jistr/vim-nerdtree-tabs'
        Plug 'Xuyuanp/nerdtree-git-plugin'

            let g:NERDTreeIndicatorMapCustom = {
                \ "Modified"  : "M",
                \ "Staged"    : "S",
                \ "Untracked" : "U",
                \ "Renamed"   : "R",
                \ "Unmerged"  : "N",
                \ "Deleted"   : "X",
                \ "Dirty"     : "D",
                \ "Clean"     : "C",
                \ 'Ignored'   : 'I',
                \ "Unknown"   : "?"
                \ }

            let g:NERDTreeShowIgnoredStatus = 1

"               " Sync open file with NERDTree
"            function! IsNERDTreeOpen()
"              return exists("t:NERDTreeBufName")
"               \ && (bufwinnr(t:NERDTreeBufName) != -1)
"            endfunction
"
"            " Call NERDTreeFind if NERDTree is active, current window
"            " contains a modifiable file, and we're not in vimdiff
"            function! SyncTree()
"              if &modifiable && IsNERDTreeOpen() && strlen(expand('%'))
"                   \ > 0 && !&diff
"                NERDTreeFind
"                wincmd p
"              endif
"            endfunction
"
"            " Highlight currently open buffer in NERDTree
"            autocmd BufEnter * call SyncTree()
"

            noremap <F10> :NERDTreeToggle<CR>

            function!  NERDToggleTreeShowIgnoredStatus()
                if g:NERDTreeShowIgnoredStatus
                    let g:NERDTreeShowIgnoredStatus = 0
                else
                    let g:NERDTreeShowIgnoredStatus = 1
                endif
            endfunction
            :command! NERDTreeShowIgnoredStatus silent :call
             \ NERDToggleTreeShowIgnoredStatus()


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Tag explorer to move to tag location inside a file
        Plug 'https://github.com/majutsushi/tagbar'
            noremap <F8> :TagbarToggle<CR>
            noremap <F11> :TagbarToggle<CR>



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Undo Tree explorer
        Plug 'https://github.com/mbbill/undotree'
            nnoremap <F9> :UndotreeToggle<cr>




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"TAGS generation """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Cscope results navigation using quickfix window.
"    Plug 'ronakg/quickr-cscope.vim'
"        let g:quickr_cscope_use_qf_g = 1
"        let g:quickr_cscope_keymaps = 0
"        let g:quickr_cscope_autoload_db = 1
"        let g:quickr_cscope_program = 'gtags-cscope'
"        let g:quickr_cscope_db_file = 'GTAGS'
"        nmap <C-g>s <plug>(quickr_cscope_global_split)
"        nmap <C-g>v <plug>(quickr_cscope_global_vert_split^)
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Tag Higliting from Cscope
		"Plug 'skroll/taghighlight'
			Plug 'skroll/vim-easycolour'
		"if expand('%:t')== 'colortest.txt'
		"endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"cscope configuration/integration
    if has('cscope')

            "Update ctags database by hotkey
        "function! UpdateTags()
        " execute ":!ctags -R --languages=C++ --c++-kinds=+p
        "       \ --fields=+iaS --extra=+q ./"
        " echohl StatusLine | echo "C/C++ tag updated" | echohl None
        "endfunction
        "nnoremap <F5> :call UpdateTags()


            "Updates ctags when opening vim or write a file
        "autocmd FileWritePost,BufWritePost,FilterWritePost,FileAppendPost
		"								\ *.c,*.cpp,*.h silent !ctags -R &
        "autocmd BufWrite *.c,*.h silent !ctags -R -f
         "                              \ ~/.tags/last %:p:h 2>/dev/NULL
        "autocmd BufWrite *.cpp,*.hpp silent !ctags "-R -f
		"                              \ ~/.tags/last_utest %:p:h 1>/dev/NULL


             "set scope program and database
        set cscopeprg=/usr/bin/cscope

        let $GTAGSCONF='/usr/share/gtags/gtags.conf'
        let $GTAGSLABEL='pygments'

        if filereadable('$PWD/.root/cscope.out')
            cs add $PWD/.tags/cscope.out
        elseif filereadable('.cache/tags/cscope.out')
            cs add '.cache/tags/cscope.out
        elseif filereadable('~/.cache/tags/cscope.out')
            cs add '~/.cache/tags/cscope.out
        elseif filereadable('~/.config/tags/cscope.out')
            cs add '~/.config/tags/cscope.out
        elseif filereadable('./cscope.out')
            cs add cscope.out
        elseif $CSCOPE_DB !=# ''
            cs add ~/.tags/cscope_last.out
       endif


            "use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
        set cscopetag


            "check cscope for definition of a symbol before checking ctags.
            "set to 1 if you want the reverse search order.
        set cscopetagorder=0


            "show msg when any other cscope db added
        set cscopeverbose


            "results should (not) added
         set cscopequickfix=s-,c-,d-,i-,t-,e-,a-
        "set cscopequickfix=s-,c-,d-,i-,t-,e-,a-,g-,f-
        "set cscopequickfix=s+,c+,d+,i+,t+,e+,a+,g+,f+


            "By default Vim will only wait 1 second for each keystroke
            "If so, you should either turn off mapping timeouts via 'notimeout'.
        "set notimeout
        "set timeoutlen=4000
        "set ttimeout
        "set ttimeoutlen=100


            "Desscription: cscope_maps plugin
        "" These mappings for Ctrl-] (right bracket) and Ctrl-\ (backslash)
        "" allow you to place your cursor over the function name or C symbol
        "" and quickly you to query cscope for any matches.
        "nmap <C-\>s :lcs find s <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>g :lcs find g <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>c :lcs find c <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>t :lcs find t <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>e :lcs find e <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>f :lcs find f <C-R>=expand("<cfile>")<CR><CR>
        "nmap <C-\>i :lcs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
        "nmap <C-\>d :lcs find d <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>a :lcs find a <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-\>n :cn <C-R>
        "nmap <C-\>l :cl <C-R>


        ""Using 'CTRL-spacebar' (intepreted as CTRL-@ by vim) then a search type
        ""makes the vim window split horizontally, with search result displayed
        ""inthe new window.
        "nmap <C-]>s :scs find s <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>g :scs find g <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>c :scs find c <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>t :scs find t <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>e :scs find e <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>f :scs find f <C-R>=expand("<cfile>")<CR><CR>
        "nmap <C-]>i :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
        "nmap <C-]>d :scs find d <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]>a :scs find a <C-R>=expand("<cword>")<CR><CR>


        "" Hitting CTRL-space *twice* before the search type does a vertical
        "" split instead of a horizontal one (vim 6 and up only)
        "" (Note: you may wish to put a 'set split right' in your .vimrc
        "" if you prefer the new window on the right instead of the left
        "nmap <C-]><C-]>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>
        "nmap <C-]><C-]>i :vert scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
        "nmap <C-]><C-]>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-]><C-]>a :vert scs find a <C-R>=expand("<cword>")<CR><CR>

        "" Or you may use the following scheme, inspired by Vim/Cscope tutorial
        "" from Cscope Home Page (http://cscope.sourceforge.net/):
        "nmap <C-_>s :cs find s <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>g :cs find g <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>c :cs find c <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>t :cs find t <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>e :cs find e <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
        "nmap <C-_>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
        "nmap <C-_>d :cs find d <C-R>=expand("<cword>")<CR><CR>
        "nmap <C-_>a :cs find a <C-R>=expand("<cword>")<CR><CR>
    endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Async plugin for Vim/NeoVim to ease the use of ctags/gtags
        Plug 'jsfaint/gen_tags.vim'

                "Bind Keys
				" 0 or s: Find this symbol
				" 1 or g: Find this definition
				" 2 or d: Find functions called by this function
				" 3 or c: Find functions calling this function
				" 4 or t: Find this text string
				" 6 or e: Find this egrep pattern
				" 7 or f: Find this file
				" 8 or i: Find files #including this file
				" 9 or a: Find places where this symbol is assigned a value

				"Define own keybindings
            let g:gen_tags#gtags_default_map=0
		    nmap <Leader>ga :cs find a <C-R>=expand('<cword>')<CR><CR>
			nmap <Leader>gc :cs find c <C-R>=expand('<cword>')<CR><CR>
		    nmap <Leader>gd :cs find d <C-R>=expand('<cword>')<CR><CR>
		    nmap <Leader>ge :cs find e <C-R>=expand('<cword>')<CR><CR>
		    nmap <Leader>gf :cs find f <C-R>=expand('<cfile>')<CR><CR>
		    nmap <Leader>gg :cs find g <C-R>=expand('<cword>')<CR><CR>
		    nmap <Leader>gi :cs find i <C-R>=expand('<cfile>')<CR><CR>
		    nmap <Leader>gt :cs find t <C-R>=expand('<cword>')<CR><CR>
		    nmap <Leader>gs :cs find s <C-R>=expand('<cword>')<CR><CR>
		    nmap gs :cs find s <C-R>=expand('<cword>')<CR><CR>

            autocmd User GenTags#CtagsLoaded echo "Tags loaded"
            autocmd User GenTags#GtagsLoaded echo "Tags loaded"

           let $GTAGSCONF='/usr/share/gtags/gtags.conf'
           let $GTAGSLABEL='pygments'

            let g:gen_tags#ctags_auto_gen=1
            let g:gen_tags#ctags_auto_update=0
            let g:gen_tags#gtags_auto_gen=1
            let g:gen_tags#gtags_auto_update=0

            let g:gen_tags#blacklist = [ '$HOME' ]
            let g:gen_tags#root_marker='.git'
            "let g:gen_tags#ctags_opts = '--c++-kinds=+px --c-kinds=+px'
            "let g:gen_tags#ctags_opts = '-c --verbose'
            "let g:gen_tags#ctags_opts = ['--c++-kinds=+px', '--c-kinds=+px']
            "autocmd User GenTags#GtagsLoaded nnoremap gd <c-]>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Guttag Ctag, Cscope, Gtags, Gscope handling and integration

"Plug 'ludovicchabant/vim-gutentags'
"#Plug 'skywind3000/gutentags_plus'
"
"
"                " enable gtags module
"            let g:gutentags_modules = ['gtags_cscope', 'ctags', 'cscope']
"
"                "generate databases in my cache directory,
"                "prevent gtags files polluting my project
"            "let g:gutentags_cache_dir = expand('~/.cache/tags')
"            let g:gutentags_cache_dir = expand('~/.cache/tags')
"            "let g:gutentags_scopefile = 'cscope.db'
"            "let g:gutentags_ctags_tagfile = 'ctags.db'
"            let g:gutentags_gtags_dbpath = ''
"
"
"                "Generate tags also when vim gets open. Not only till writing.
"            "let g:gutentags_generate_on_empty_buffer = 1
"
"
"                "configure project root markers.
"            let g:gutentags_add_default_project_roots = 0
"            let g:gutentags_project_root = ['.cache']
"
"
"                "change focus to quickfix window after search (optional).
"            let g:gutentags_plus_switch = 1
"
"                "Let gutentags run on fle write
"            let g:gutentags_generate_on_new = 1
"            let g:gutentags_generate_on_missing = 1
"            let g:gutentags_generate_on_write = 1
"            let g:gutentags_generate_on_empty_buffer = 0
"
"
"                "Let Gutentags generate more info for the tags.
"                "Explaining --fields=+ailmnS
"                "(info gathered from: $ ctags --list-fields)
"                "    a: Access (or export) of class members
"                "    i: Inheritance information
"                "    l: Language of input file containing tag
"                "    m: Implementation information
"                "    n: Line number of tag definition
"                "    S: Signature of routine (e.g. prototype or parameter list)
"            let g:gutentags_ctags_extra_args = [
"                 \ '--tag-relative=yes',
"                 \ '--fields=+ailmnS',
"                 \ ]
"
"
"                "Define a list of files for indexing by GutenTag
"            "let g:gutentags_file_list_command = 'find . -type f'
"
"
"                "Enable extra vim commands like
"                "|GutentagsToggleEnabled| and |GutentagsUnlock|.
"            let g:gutentags_define_advanced_commands = 1
"
"
"                "Making GutenTags faster by ignoring a lot of filetypes.
"            let g:gutentags_exclude_filetypes = ['.*']
"            let g:gutentags_exclude_project_root = ['./.root']
"            let g:gutentags_ctags_exclude_widignore = 1 "add wildignore file"
"            let g:gutentags_ctags_exclude = [
"                  \ '*.git','*.svg', '*.hg',
"            	  \ '*.db',
"                  \ '*/tests/*',
"                  \ 'build',
"                  \ 'dist',
"                  \ '*sites/*/files/*',
"                  \ 'bin', '*.o', '*.p1',
"                  \ 'node_modules',
"                  \ 'bower_components',
"                  \ 'cache',
"                  \ 'compiled', 'output', 'debug', 'out', '*.out',
"                  \ 'docs',
"                  \ 'example',
"                  \ 'bundle',
"                  \ 'vendor',
"                  \ '*.md',
"                  \ '*-lock.json',
"                  \ '*.lock',
"                  \ '*bundle*.js',
"                  \ '*build*.js',
"                  \ '.*rc*',
"                  \ '*.json',
"                  \ '*.min.*',
"                  \ '*.map',
"                  \ '*.bak',
"                  \ '*.zip',
"                  \ '*.pyc',
"                  \ '*.class',
"                  \ '*.sln',
"                  \ '*.Master',
"                  \ '*.csproj', '*.csproj.user', '*.*proj*',
"                  \ '*.tmp',
"                  \ '*.cache',
"                  \ '*.pdb',
"                  \ 'tags*', '*.tag', '*.tags', '*.*scope*', '.scope',
"                  \ 'cscope.*',
"                  \ '*.css',
"                  \ '*.less',
"                  \ '*.scss',
"                  \ '*.exe', '*.dll',
"                  \ '*.mp3', '*.ogg', '*.flac',
"                  \ '*.swp', '*.swo',
"                  \ '*.bmp', '*.gif', '*.ico', '*.jpg', '*.png',
"                  \ '*.rar', '*.zip', '*.tar', '*.tar.*', '.7z',
"                  \ '*.pdf', '*.doc', '*.docx', '*.ppt', '*.pptx',
"                  \ ]
"
"                "Bind Keys
"				" 0 or s: Find this symbol
"				" 1 or g: Find this definition
"				" 2 or d: Find functions called by this function
"				" 3 or c: Find functions calling this function
"				" 4 or t: Find this text string
"				" 6 or e: Find this egrep pattern
"				" 7 or f: Find this file
"				" 8 or i: Find files #including this file
"				" 9 or a: Find places where this symbol is assigned a value
"
"                " disable the default keymaps (and set them manual):
"                let g:gutentags_plus_nomap = 1
"              noremap <silent> <leader><leader>gs :GscopeFind s <C-R><C-W><cr>
"              noremap <silent> <leader><leader>gg :GscopeFind g <C-R><C-W><cr>
"              noremap <silent> <leader><leader>gc :GscopeFind c <C-R><C-W><cr>
"              noremap <silent> <leader><leader>gt :GscopeFind t <C-R><C-W><cr>
"              noremap <silent> <leader><leader>ge :GscopeFind e <C-R><C-W><cr>
"              noremap <silent> <leader><leader>gf :GscopeFind f <C-R>=expand("<cfile>")<cr><cr>
"              noremap <silent> <leader><leader>gi :GscopeFind i <C-R>=expand("<cfile>")<cr><cr>
"              noremap <silent> <leader><leader>gd :GscopeFind d <C-R><C-W><cr>
"              noremap <silent> <leader><leader>ga :GscopeFind a <C-R><C-W><cr>
"              noremap <silent> <leader><leader>gz :GscopeFind z <C-R><C-W><cr>
"
""            noremap <silent> <C-\>gs :GscopeFind s <C-R><C-W><cr>
""            noremap <silent> <C-\>gg :GscopeFind g <C-R><C-W><cr>
""            noremap <silent> <C-\>gc :GscopeFind c <C-R><C-W><cr>
""            noremap <silent> <C-\>gt :GscopeFind t <C-R><C-W><cr>
""            noremap <silent> <C-\>ge :GscopeFind e <C-R><C-W><cr>
""            noremap <silent> <C-\>gf :GscopeFind f <C-R>
""                                            \ =expand("<cfile>")<cr><cr>
""            noremap <silent> <C-\>gi :GscopeFind i <C-R>
""                                            \ =expand("<cfile>")<cr><cr>
""            noremap <silent> <C-\>gd :GscopeFind d <C-R><C-W><cr>
""            noremap <silent> <C-\>ga :GscopeFind a <C-R><C-W><cr>
""            noremap <silent> <C-\>gz :GscopeFind z <C-R><C-W><cr>
""
"            " Add autogroup for tag generation
"            augroup tagAug
"              autocmd!
"              autocmd FileType git,gitcommit,gitrebase,gitsendemail,*
"                          \ :let g:gutentags_enabled=0
"            augroup end
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Makes Quickfixbar writeable to direct edit files. Once you save the quickfix
"buffer, your changes will be made in the actual file an entry points to.
"This works by pattern replacement. It DOES NOT work on line with same pattern.
"You can also delete lines in the quickfix to pipe a cleaner list to commands.
"        Plug 'stefandtw/quickfix-reflector.vim'
"
"            let g:qf_modifiable = 1
"            let g:qf_join_changes = 1
"            let g:qf_write_changes = 1
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"An other plugin to makes Quickfixbar writeable. No configuration  needed.
"        Plug 'https://github.com/itchyny/vim-qfedit'
"
"            "The default filename for storing and loading quickfix and location
"            "lists  customizable by setting the following variables in your
"            "vimrc:
"                let g:editqf_saveqf_filename  = "quickfix.list"
"                let g:editqf_saveloc_filename = "location.list"
"
"            "Jump to the edited error when editing finished:
"                let g:editqf_jump_to_error = 1
"
"            "Store absolute filename when adding a new note
"                let g:editqf_store_absolute_filename = 1
"
"            "The default keybinding <leader>n for adding a quickfix note can be
"            "custuomized by defining a mapping in your vimrc:
"            "    nmap <leader>n <Plug>QFAddNote
"            "    nmap <leader>N <Plug>QFAddNotePattern
"            "    nmap <leader>l <Plug>LocAddNote
"            "    nmap <leader>L <Plug>LocAddNotePattern
"            "
"            "The above mappings can be turned off by setting:
"            "    let g:editqf_no_mappings = 1
"



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""" COMMANDS """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Save yanks in a circular list for later use.
        Plug 'https://github.com/svermeulen/vim-yoink'

            nmap <c-n> <plug>(YoinkPostPasteSwapBack)
            "nmap <c-p> <plug>(YoinkPostPasteSwapForward)
            let g:ctrlp_map=''  "to work with ctrl-p
            nmap <expr> <c-p> yoink#isSwapping() ?
                    \ '<plug>(YoinkPostPasteSwapForward)'
            nmap p <plug>(YoinkPaste_p)
            nmap P <plug>(YoinkPaste_P)
            nmap <c-=> <plug>(YoinkPostPasteToggleFormat)
            nmap [y <plug>(YoinkRotateBack)
            nmap ]y <plug>(YoinkRotateForward)

            let g:yoinkMaxItems=20                  "History size. Default: 10.
            let g:yoinkSyncNumberedRegisters=1      "Default
            let g:yoinkIncludeDeleteOperations=0    "add |x| |d|  |s| to history
            "let g:yoinkSavePersistently=1           "Requires Neovim.
            let g:yoinkAutoFormatPaste=0            "0=off, can be used by :cmd
            let g:yoinkMoveCursorToEndOfPaste=0     "1=multiline feature, 0=vim
            let g:yoinkSwapClampAtEnds=0            "0=Cycle ynklist arround
            let g:yoinkIncludeNamedRegisters=1      "Deault '1'
            let g:yoinkSyncSystemClipboardOnFocus=1 "Default '1'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Fuzzy finder like FZF but with mor focus on Vim
"
"		if has('nvim')
"		  Plug 'Shougo/denite.nvim', { 'do': ':UpdateRemotePlugins' }
"		else
"		  Plug 'Shougo/denite.nvim'
"		  Plug 'roxma/nvim-yarp'
"		  Plug 'roxma/vim-hug-neovim-rpc'
"		endif
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Fuzzy finding/grep of files,tags,history and much more

		Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
        Plug 'junegunn/fzf.vim'
        Plug 'tiagoinacio/fzf-bookmark.vim'

			let g:fzf_action = {
			  \ 'ctrl-t': 'tab split',
			  \ 'ctrl-x': 'split',
			  \ 'ctrl-v': 'vsplit' }

			" Enable per-command history.
			" CTRL-N and CTRL-P will be automatically bound to next-history and
			" previous-history instead of down and up. If you don't like the change,
			" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
			let g:fzf_history_dir = '~/.local/share/fzf-history'

			map <leader>ff :Files<CR>
			map <leader>fb :Buffers<CR>
			nnoremap <leader>fg :Rg<CR>

                " [Buffers] Jump to the existing window if possible
            "let g:fzf_buffers_jump = 1
                " [Tags] Command to generate tags file
            "let g:fzf_commands_expect = 'alt-enter,ctrl-x'


			let g:fzf_tags_command = 'ctags -R'
			" Border color
			let g:fzf_layout = {'up':'~90%', 'window': { 'width': 0.8, 'height': 0.8,'yoffset':0.5,'xoffset': 0.5, 'highlight': 'Todo', 'border': 'sharp' } }
			" let g:fzf_layout = { 'window': 'vs' }
			let $FZF_DEFAULT_OPTS = '--layout=reverse --info=inline'
			let $FZF_DEFAULT_COMMAND="rg --files --hidden"


			" Customize fzf colors to match your color scheme
"			let g:fzf_colors =
"			\ { 'fg':      ['fg', 'Normal'],
"			  \ 'bg':      ['bg', 'Normal'],
"			  \ 'hl':      ['fg', 'Comment'],
"			  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
"			  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
"			  \ 'hl+':     ['fg', 'Statement'],
"			  \ 'info':    ['fg', 'PreProc'],
"			  \ 'border':  ['fg', 'Ignore'],
"			  \ 'prompt':  ['fg', 'Conditional'],
"			  \ 'pointer': ['fg', 'Exception'],
"			  \ 'marker':  ['fg', 'Keyword'],
"			  \ 'spinner': ['fg', 'Label'],
"			  \ 'header':  ['fg', 'Comment'] }

			" Enable per-command history
			" - History files will be stored in the specified directory
			" - When set, CTRL-N and CTRL-P will be bound to 'next-history' and
			"   'previous-history' instead of 'down' and 'up'.

			let g:fzf_history_dir = '~/.local/share/fzf-history'

			let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }
			let g:fzf_layout = { 'down': '30%' }
			autocmd! FileType fzf
			autocmd  FileType fzf set laststatus=0 noshowmode noruler
			  \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler
			"
			"Get Files
			command! -bang -nargs=? -complete=dir Files
			    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)


			" Get text in files with Rg
			command! -bang -nargs=* Rg
			  \ call fzf#vim#grep(
			  \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
			  \   fzf#vim#with_preview(), <bang>0)

			" Ripgrep advanced
			function! RipgrepFzf(query, fullscreen)
			  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
			  let initial_command = printf(command_fmt, shellescape(a:query))
			  let reload_command = printf(command_fmt, '{q}')
			  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
			  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
			endfunction

			command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)

			" Git grep
			command! -bang -nargs=* GGrep
			  \ call fzf#vim#grep(
			  \   'git grep --line-number '.shellescape(<q-args>), 0,
			  \   fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)


			  " Open files in horizontal split
			  nnoremap <silent> <Leader>s :call fzf#run({
					  \   'down': '40%',
					  \   'sink': 'botright split' })<CR>

			  " Open files in vertical horizontal split
			  nnoremap <silent> <Leader>v :call fzf#run({
					  \   'right': winwidth('.') / 2,
					  \   'sink':  'vertical botright split' })<CR>

"			  nnoremap <silent> <Leader>C :call fzf#run({
"					  \   'source':
"					  \     map(split(globpath(&rtp, "colors/*.vim"), "\n"),
"					  \         "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')"),
"					  \   'sink':    'colo',
"					  \   'options': '+m',
"					  \   'left':    30
"					  \ })<CR>
"
				function! s:buflist()
				    redir => ls
					silent ls
					redir END
					return split(ls, '\n')
				endfunction

				function! s:bufopen(e)
					execute 'buffer' matchstr(a:e, '^[ 0-9]*')
				endfunction

				nnoremap <silent> <Leader><Enter> :call fzf#run({
					\   'source':  reverse(<sid>buflist()),
					\   'sink':    function('<sid>bufopen'),
					\   'options': '+m',
					\   'down':    len(<sid>buflist()) + 2
					\ })<CR>

				command! FZFMru call fzf#run({
						\  'source':  v:oldfiles,
						\  'sink':    'e',
						\  'options': '-m -x +s',
						\  'down':    '40%'})

				command! FZFMru call fzf#run({
					\ 'source':  reverse(s:all_files()),
					\ 'sink':    'edit',
					\ 'options': '-m -x +s',
					\ 'down':    '40%' })

				function! s:all_files()
				return extend(
					    \ filter(copy(v:oldfiles),
						\        "v:val !~ 'fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"),
						\ map(filter(range(1, bufnr('$')), 'buflisted(v:val)'), 'bufname(v:val)'))
			  endfunction

			function! s:tags_sink(line)
			  let parts = split(a:line, '\t\zs')
			  let excmd = matchstr(parts[2:], '^.*\ze;"\t')
			  execute 'silent e' parts[1][:-2]
			  let [magic, &magic] = [&magic, 0]
			  execute excmd
			  let &magic = magic
			endfunction

			function! s:tags()
			  if empty(tagfiles())
			    echohl WarningMsg
			    echom 'Preparing tags'
			    echohl None
			    call system('ctags -R')
			  endif

			  call fzf#run({
			  \ 'source':  'cat '.join(map(tagfiles(), 'fnamemodify(v:val, ":S")')).
			  \            '| grep -v -a ^!',
			  \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
			  \ 'down':    '40%',
			  \ 'sink':    function('s:tags_sink')})
			endfunction

			command! Tags call s:tags()

			function! s:align_lists(lists)
			  let maxes = {}
			  for list in a:lists
			    let i = 0
			    while i < len(list)
			      let maxes[i] = max([get(maxes, i, 0), len(list[i])])
			      let i += 1
			    endwhile
			  endfor
			  for list in a:lists
			    call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
			  endfor
			  return a:lists
			endfunction

			function! s:btags_source()
			  let lines = map(split(system(printf(
			    \ 'ctags -f - --sort=no --excmd=number --language-force=%s %s',
			    \ &filetype, expand('%:S'))), "\n"), 'split(v:val, "\t")')
			  if v:shell_error
			    throw 'failed to extract tags'
			  endif
			  return map(s:align_lists(lines), 'join(v:val, "\t")')
			endfunction

			function! s:btags_sink(line)
			  execute split(a:line, "\t")[2]
			endfunction

			function! s:btags()
			  try
			    call fzf#run({
			    \ 'source':  s:btags_source(),
			    \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
			    \ 'down':    '40%',
			    \ 'sink':    function('s:btags_sink')})
			  catch
			    echohl WarningMsg
			    echom v:exception
			    echohl None
			  endtry
			endfunction

			command! BTags call s:btags()

			function! s:line_handler(l)
			  let keys = split(a:l, ':\t')
			  exec 'buf' keys[0]
			  exec keys[1]
			  normal! ^zz
			endfunction

			function! s:buffer_lines()
			  let res = []
			  for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
			    call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
			  endfor
			  return res
			endfunction

			command! FZFLines call fzf#run({
			\   'source':  <sid>buffer_lines(),
			\   'sink':    function('<sid>line_handler'),
			\   'options': '--extended --nth=3..',
			\   'down':    '60%'
			\})

			function! s:ag_to_qf(line)
			  let parts = split(a:line, ':')
			  return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
			        \ 'text': join(parts[3:], ':')}
			endfunction

			function! s:ag_handler(lines)
			  if len(a:lines) < 2 | return | endif

			  let cmd = get({'ctrl-x': 'split',
			               \ 'ctrl-v': 'vertical split',
			               \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
			  let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

			  let first = list[0]
			  execute cmd escape(first.filename, ' %#\')
			  execute first.lnum
			  execute 'normal!' first.col.'|zz'

			  if len(list) > 1
			    call setqflist(list)
			    copen
			    wincmd p
			  endif
			endfunction

			command! -nargs=* Ag call fzf#run({
			\ 'source':  printf('ag --nogroup --column --color "%s"',
			\                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
			\ 'sink*':    function('<sid>ag_handler'),
			\ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. '.
			\            '--multi --bind=ctrl-a:select-all,ctrl-d:deselect-all '.
			\            '--color hl:68,hl+:110',
			\ 'down':    '50%'
			\ })

			function! s:fzf_neighbouring_files()
			  let current_file =expand("%")
			  let cwd = fnamemodify(current_file, ':p:h')
			  let command = 'ag -g "" -f ' . cwd . ' --depth 0'

			  call fzf#run({
			        \ 'source': command,
			        \ 'sink':   'e',
			        \ 'options': '-m -x +s',
			        \ 'window':  'enew' })
			endfunction

			command! FZFNeigh call s:fzf_neighbouring_files()

			command! -bang Args call fzf#run(fzf#wrap('args',
			    \ {'source': map([argidx()]+(argidx()==0?[]:range(argc())[0:argidx()-1])+range(argc())[argidx()+1:], 'argv(v:val)')}, <bang>0))

			function! MyUniq(lst)
			    return filter(a:lst, 'count(a:lst, v:val) == 1')
			endfunction
			command! -bang Netrwhist call fzf#run(fzf#wrap('netrw_dirhist',
			    \ {'source':
			    \ !exists('g:netrw_dirhist_cnt')
			    \   ?"tail -n +3 ".g:netrw_home.".netrwhist | cut -d \"'\" -f2- | rev | cut -d \"'\" -f2- | rev | awk '!seen[$0]++'"
			    \   :MyUniq(map(range(1,g:netrw_dirhist_cnt), 'g:netrw_dirhist_{v:val}'))
			    \ }, <bang>0))


			"
			" choose from templates and apply to file
			"
			function! s:read_template_into_buffer(template)
				" has to be a function to avoid the extra space fzf#run insers otherwise
				execute '0r ~/.vim/templates/'.a:template
			endfunction

			command! -bang -nargs=* LoadTemplate call fzf#run({
						\   'source': 'ls -1 ~/.config/nvim/templates',
						\   'down': 20,
						\   'sink': function('<sid>read_template_into_buffer')
						\ })

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"improved star (*) motions.
"        "Plug 'haya14busa/vim-asterisk'
"            map *   <Plug>(asterisk-*)
"            map #   <Plug>(asterisk-#)
"            map g*  <Plug>(asterisk-g*)
"            map g#  <Plug>(asterisk-g#)
"            map z*  <Plug>(asterisk-z*)
"            map gz* <Plug>(asterisk-gz*)
"            map z#  <Plug>(asterisk-z#)
"            map gz# <Plug>(asterisk-gz#)
"
""                "If you want to set "z" (stay) behavior as default >
""		    "map *  <Plug>(asterisk-z*)
""		    "map #  <Plug>(asterisk-z#)
""		    "map g* <Plug>(asterisk-gz*)
""            "map g# <Plug>(asterisk-gz#)
""
""             "keep cursor position while moving across matches. Default = 0.
""            let g:asterisk#keeppos = 1
"
"                "ONLY if is.vim plugin is used
"            map *  <Plug>(asterisk-z*)<Plug>(is-nohl-1)
"            map g* <Plug>(asterisk-gz*)<Plug>(is-nohl-1)
"            map #  <Plug>(asterisk-z#)<Plug>(is-nohl-1)
"            map g# <Plug>(asterisk-gz#)<Plug>(is-nohl-1)
"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Extends the . command to plugins.
        Plug 'tpope/vim-repeat'

        "Example: Adding support to a plugin or command:
            "silent! call repeat#set("\<Plug>MyWonderfulMap", v:count)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Makes motions like f,T,(,},[s,]s,... repeatble  by press of C-hjkl ...
        Plug '~/.vim/plugged/repeatable-motions'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Displays all Number formats for a given number by simple press gA
"        Plug 'glts/vim-radical'
"        Plug 'glts/vim-magnum'
"
"            "Ignore default mappings
"        let g:radical_no_mappings=1
"
"		nmap <Leader>cta <Plug>RadicalView
"    	xmap <Leader>cta <Plug>RadicalView
"        nmap <Leader>ctd <Plug>RadicalCoerceToDecimal
"        xmap <Leader>ctd <Plug>RadicalCoerceToDecimal
"        nmap <Leader>ctx <Plug>RadicalCoerceToHex
"        xmap <Leader>ctx <Plug>RadicalCoerceToHex
"        nmap <Leader>cto <Plug>RadicalCoerceToOctal
"        xmap <Leader>cto <Plug>RadicalCoerceToOctal
"        nmap <Leader>ctb <Plug>RadicalCoerceToBinary
"        xmap <Leader>ctb <Plug>RadicalCoerceToBinary
"
"
"        "All mappings base of the target number can be forced by giving a
"        "count.  For example, "16gA" targets a hexadecimal number.
"
"            "Correction of output
"        "b:radical_bases = {8: {'format': '0o%s'}}
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Repeat <count>hjkl ... by ,(down) and ; (up)
        Plug 'https://github.com/Houl/repmo-vim'

            "Map a motion and its reverse motion:
            noremap <expr> h repmo#SelfKey('h', 'l')|sunmap h
            noremap <expr> l repmo#SelfKey('l', 'h')|sunmap l

            "If you like `:noremap j gj', you can keep that:
            map <expr> j repmo#Key('gj', 'gk')|sunmap j
            map <expr> k repmo#Key('gk', 'gj')|sunmap k

            "Repeat the last [count]motion or the last zap-key:
            map <expr> ; repmo#LastKey(';')|sunmap ;
            map <expr> , repmo#LastRevKey(',')|sunmap ,

            "Add these mappings when repeating with `;' or `,':
            noremap <expr> f repmo#ZapKey('f')|sunmap f
            noremap <expr> F repmo#ZapKey('F')|sunmap F
            noremap <expr> t repmo#ZapKey('t')|sunmap t
            noremap <expr> T repmo#ZapKey('T')|sunmap T

            "With argument, you can make f remember the count (same for F,t,T)
            noremap <expr> f repmo#ZapKey('f', 1)|sunmap f

            "Scroll commands work too:
            noremap <expr> <C-E> repmo#SelfKey('<C-E>', '<C-Y>')
            noremap <expr> <C-Y> repmo#SelfKey('<C-Y>', '<C-E>')

            "Alternative repetition keys (also working in addition to ; and ,):

            " repeat the last [count]motion:
            ":map <expr> <Space> repmo#LastKey('')|sunmap <Space>
            ":map <expr> <BS>    repmo#LastRevKey('')|sunmap <BS>

            "Number of minimal couts this plugin shoud work
            let g:repmo_require_count = 0


            "ATTATION: only if if Sneek plugin  active
            map  <expr> ; repmo#LastKey('<Plug>Sneak_;')|sunmap ;
            map  <expr> , repmo#LastRevKey('<Plug>Sneak_,')|sunmap ,

            map  <expr> s repmo#ZapKey('<Plug>Sneak_s')|ounmap s|sunmap s
            map  <expr> S repmo#ZapKey('<Plug>Sneak_S')|ounmap S|sunmap S
            omap <expr> z repmo#ZapKey('<Plug>Sneak_s')
            omap <expr> Z repmo#ZapKey('<Plug>Sneak_S')
"            map  <expr> f repmo#ZapKey('<Plug>Sneak_f')|sunmap f
"            map  <expr> F repmo#ZapKey('<Plug>Sneak_F')|sunmap F
"            map  <expr> t repmo#ZapKey('<Plug>Sneak_t')|sunmap t
"            map  <expr> T repmo#ZapKey('<Plug>Sneak_T')|sunmap T


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Provides multiple cursors to work (like alter, insert, ...) on different
""locations at the same time. But its confusing and error prone.
"        Plug 'terryma/vim-multiple-cursors'
"
"
"                "If you don't like the plugin taking over your key bindings,
"                "you can turn it off and reassign them the way you want:
"            let g:multi_cursor_use_default_mapping=0
"
"
"                " Default mapping
"            let g:multi_cursor_start_word_key      = '<C-n>'
"            let g:multi_cursor_select_all_word_key = '<A-n>'
"            let g:multi_cursor_start_key           = 'g<C-n>'
"            let g:multi_cursor_select_all_key      = 'g<A-n>'
"            let g:multi_cursor_next_key            = '<C-n>'
"            let g:multi_cursor_prev_key            = '<C-p>'
"            let g:multi_cursor_skip_key            = '<C-x>'
"            let g:multi_cursor_quit_key            = '<Esc>'





""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple counts the number of search results and shows the location like 3/47
"        Plug 'osyo-manga/vim-anzu'
"
"            " mapping
"            nmap n <Plug>(anzu-n-with-echo)
"            nmap N <Plug>(anzu-N-with-echo)
"            nmap * <Plug>(anzu-star-with-echo)
"            nmap # <Plug>(anzu-sharp-with-echo)
"
"            " clear status
"            nmap <Esc><Esc> <Plug>(anzu-clear-search-status)
"
"            " status line
"            set statusline=%{anzu#search_status()}
"
"            "ATTATION:  Only if is.vim is used
"            map n <Plug>(is-nohl)<Plug>(anzu-n-with-echo)
"            map N <Plug>(is-nohl)<Plug>(anzu-N-with-echo)
"



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" GREP and DIFF"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Code search via ack or Ripgrep
        "Plug 'idbrii/vim-notgrep' "Code search via awk

        "    if has("ack-grep")
        "    let g:ackprg="ack-grep -H --nocolor --nogroup --column"
        "    endif

        "    "nnoremap <unique> <Leader>jq :<C-u>NotGrepFromSearch<CR>
        "    "    " Search for word (\b  word boundary).
        "    "nnoremap <unique> <Leader>jw :<C-u>NotGrep \b<cword>\b<CR>
        "    "nnoremap <unique> <Leader>jW :<C-u>NotGrep \b<cWORD>\b<CR>
        "    "xnoremap <unique> <Leader>jw "cy:<C-u>call
        "    "           \ notgrep#search#NotGrep('grep', '\b'. @c .'\b')<CR>
        "    "    " Less precise. Similar to `*` vs `g*`.
        "    "nnoremap <unique> <Leader>jgw :<C-u>NotGrep <cword><CR>
        "    "nnoremap <unique> <Leader>jgW :<C-u>NotGrep <cWORD><CR>
        "    "xnoremap <unique> <Leader>jgw
        "    "           \ cy:<C-u>call notgrep#search#NotGrep('grep', @c)<CR>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Handel search and replace in multiple buffers. Also for word under cursor
"Depending on the number of open buffers this can be slow. You can do this by
"using vim buildin funcitions also.
"       Plug 'https://github.com/dkprice/vim-easygrep'


		"Keymappings:
		"
		"<Leader>vv  - Grep for the word under the cursor, match all occurences,
		"              like |gstar|
		"<Leader>vV  - Grep for the word under the cursor, match whole word,
		"              like |star|
		"<Leader>va  - Like vv, but add to existing list
		"<Leader>vA  - Like vV, but add to existing list
		"<Leader>vr  - Perform a global search on the word under the cursor
		"              and prompt for a pattern with which to replace it.
		"<Leader>vo  - Select the files to search in and set grep options
		"<Leader>vy* - Invoke any option from the options explorer, where * is
		"              the shortcut for that option.
		"              e.g. <Leader>vyr - toggles recursion
		"                   <Leader>vyb - sets buffer grepping mode
		"                   etc.


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Vimdiff command to compare howl directories
        Plug 'will133/vim-dirdiff'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Show diff differences on characters, not only on lines and make it possible to
"handle this differences by <Leader>g and <Leader>p or moving between by [b,[e
        Plug 'https://github.com/rickhowe/diffchar.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Diff two lines by just call 'LineDiff'
        Plug 'https://github.com/AndrewRadev/linediff.vim'

                "Possibilities for configuration
            "let g:linediff_indent = 1                  Default value: 0
            "let g:linediff_buffer_type = 'scratch'     Default value:"tempfile"
            "let g:linediff_first_buffer_command  = 'new'
            "let g:linediff_further_buffer_command = 'vertical new'
            "" Default values: "tabnew" and "rightbelow vertical new"
            "let g:linediff_diffopt = 'filler,iwhite'    Default value:"builtin"
            "let g:linediff_modify_statusline = 0        Default value: 1
            "let g:linediff_sign_highlight_group = "DiffChange"
            "" Default value: "Search"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Makes it possible to search a howl selected visual mode block with * / #
        Plug 'bronson/vim-visual-star-search'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple toggle / change text areas or lines forward / backwards also in visual
"mode by simple cx /cxx / cxc (visual mode). No  configuration needed.
        Plug 'tommcdo/vim-exchange'




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" LATEX """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Lightweight latex plugin tool suite than vim-latex  (see below). Does NOT
"provides functionalities which can be done by other plugins. E.g. for snippet
"use an external plugin or handle it with existing functions.
	 Plug 'https://github.com/lervag/vimtex', { 'for': ['tex'] }
"    Plug 'sylvainhalle/textidote', { 'do': 'Check if .jar is existing' }
"    Plug 'matze-dd/YaLafi', { 'do':
"			\ 'python setup.py build && sudo python setup.py install'  }
if (&ft=='tex' || &ft=='latex' || &ft=='bib' )
			let g:vimtex_syntax_enabled=0
			let g:vimtex_fold_enabled=0
			let g:vimtex_complete_enabled=1
			let g:tex_flavor = "latex"

			let g:vimtex_mappings_override_existing=1

                "Enable Autoindent
			let g:vimtex_indent_on_ampersands=1
            let g:vimtex_indent_enabled=1
            let g:vimtex_indent_bib_enabled=1
            let g:vimtex_indent_delims = {
                    \ 'open' : ['{','[','{'],
                    \ 'close' : ['}',']','}'],
                    \ 'close_indented' : 0,
                    \ 'include_modified_math' : 1,
                    \ }

            let g:vimtex_indent_ignored_envs= [
                    \ 'document'
                    \ ]

			let g:vimtex_indent_ignored_envs= []
            let g:vimtex_indent_lists= [
                  \ 'itemize',
                  \ 'description',
                  \ 'enumerate',
                  \ 'thebibliography',
                  \ ]

            let g:vimtex_indent_on_ampersands=1

            let g:vimtex_matchparen_enabled = 1
                " Enabe use of externe matching tool like match-up.vim
            let g:matchup_override_vimtex = 1
            let g:matchup_matchparen_deferred = 1

                "Enable buildin intention for bibtex files
            let g:vimtex_indent_bib_enable =1

                "Load default mappings. Will not overwrite existing mappings
            let g:vimtex_mappings_enabled = 1

                "Auto jump to first error
            let g:vimtex_quickfix_autojump =0

                "Open quickfix on error but not jumps to it.
            let g:vimtex_quickfix_mode = 2

               "Define syntax aliases and thoes to ignore
            let g:vimtex_syntax_nested = {
                \ 'aliases' : {
                    \ 'C' : 'c',
                    \ 'csharp' : 'cs',
                    \  },
                \ 'ignored' : {
                    \ 'cs' : [
                        \ 'csBraces',
                        \ ],
                    \ 'python' : [
                        \ 'pythonEscape',
                        \ 'pythonBEscape',
                        \ 'pythonBytesEscape',
                        \ ],
                    \ 'java' : [
                        \ 'javaError',
                        \ ],
                        \ 'haskell' : [
                        \ 'hsVarSym',
                        \ ],
                    \ }
                \ }

               "Quickfix interaction settings
			" let g:vimtex_quickfix_ignore_filters = [
			"         \ 'Example string to hide',
			"         \ 'A second string to hide',
			"         \ ]
			"
               "Syntax on an define syntax packages to use
"            let g:vimtex_syntax_conceal_default=1
"            let g:vimtex_syntax_conceal= [  "TODO keys for directory are need
"                  \ 'accents',
"                  \ 'fancy',
"                  \ 'math_bounds',
"                  \ 'math_delimiters',
"                  \ 'math_delimiters',
"                  \ 'math_fracs',
"                  \ 'math_super_sub',
"                  \ 'math_symbols',
"                  \ 'styles'
"                  \ ]
"
"             let g:vimtex_syntax_packages = [ "TODO keys for directory are need
"                \ 'amsmath',
"                \ 'hyperref',
"                \ 'glossaries',
"                \ 'glossaries_extra',
"                \ 'biblatex',
"                \ 'url',
"                \ 'listings'
"                \ ]
"
                "start pdf viewer after compalation
            let g:vimtex_view_automatic = 1

                " pdfviever fix to zathura
            let g:vimtex_view_method = 'zathura'

				" Close braces
			let g:vimtex_complete_close_braces=1

				" Vimtex by default prints some information while waiting
			let g:vimtex_complete_close_braces=1


                "Grammar checker
            let g:vimtex_grammar_textidote = { 'jar' :
				\ '~/.vim/plugged/textidote/textidote.jar' }
            let g:vimtex_grammar_vlty = {
	            \ 'lt_directory': '~/lib/LanguageTool',
				\ 'lt_command': 'languagetool',
	            \ 'lt_disable': 'WHITESPACE_RULE',
	            \ 'lt_enable': '',
	            \ 'lt_disablecategories': '',
	            \ 'lt_enablecategories': '',
	            \ 'server': 'my',
	            \ 'shell_options': '',
	            \ 'show_suggestions': 1,
	            \ 'encoding': 'auto',
			            \}

				" Compiler setting
		    let g:vimtex_compiler_latexmk = {
		        \ 'build_dir' : '',
		        \ 'callback' : 1,
		        \ 'continuous' : 1,
		        \ 'executable' : 'latexmk',
		        \ 'hooks' : [],
		        \ 'options' : [
		        \   '-verbose',
		        \   '-file-line-error',
		        \   '-synctex=1',
		        \   '-interaction=nonstopmode',
		        \ ],
		        \}


		    if empty(v:servername) && exists('*remote_startserver')
		      call remote_startserver('VIM')
		    endif

			 nnoremap <localleader>lt :call vimtex#fzf#run()<cr>

endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Complex but powerful LaTex suite with templates, syntax highlighting and more
"Tries to build a howl IDE into vim (mostly) without need of additional tools.
"       Plug 'https://github.com/vim-latex/vim-latex'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"WYSIWYG function: Direct render .tex file while editing.
"        "Plug 'https://github.com/xuhdev/vim-latex-live-preview'
"
"               "ATTATION: Needs to be configured before usage.
"            let g:livepreview_previewer = 'your_viewer'
"            let g:livepreview_engine = 'your_engine' . ' [options]'
"            let g:livepreview_cursorhold_recompile = 0
"




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" GIT """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Run all tasks from inside vim and makes interaction much easier this way MOSTY
        Plug 'tpope/vim-fugitive'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Shows git diff markers in the sign column and stages/previews/undoes hunks and
"partial hunks. Can be configured massively.
        Plug 'airblade/vim-gitgutter'
        let g:gitgutter_enabled = 1
        let let g:gitgutter_map_keys = 0

        omap ic <Plug>(GitGutterTextObjectInnerPending)
        omap ac <Plug>(GitGutterTextObjectOuterPending)
        xmap ic <Plug>(GitGutterTextObjectInnerVisual)
        xmap ac <Plug>(GitGutterTextObjectOuterVisual)
        nmap [g <Plug>(GitGutterPrevHunk)
        nmap ]g <Plug>(GitGutterNextHunk)
        nmap ghp <Plug>(GitGutterPreviewHunk)
        nmap ghs <Plug>(GitGutterStageHunk)
        nmap ghu <Plug>(GitGutterUndoHunk)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Ease your git workflow within vim.  From a very single vim buffer, you can
"perform main git operations in few key press.
		" Plug 'jreybert/vimagit'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Browse GitHub events (user dashboard, user/repo activity) in Vim.
"        Plug 'https://github.com/junegunn/vim-github-dashboard.git'
"
"            let g:github_dashboard={'username':'you','password':$GITHUB_TOKEN}
"            let g:github_dashboard = {}
"
"                " Dashboard window position
"                " - Options: tab, top, bottom, above, below, left, right
"                " - Default: tab
"            let g:github_dashboard['position'] = 'top'
"
"                " Disable Emoji output
"                " - Default: only enable on terminal Vim on Mac
"            let g:github_dashboard['emoji'] = 0
"
"                " Customize emoji (see http://www.emoji-cheat-sheet.com/)
"            let g:github_dashboard['emoji_map'] = {
"                \   'user_dashboard': 'blush',
"                \   'user_activity':  'smile',
"                \   'repo_activity':  'laughing',
"                \   'ForkEvent':      'fork_and_knife'
"                    \ }
"
"                " Command to open link URLs -  Default: auto-detect
"            let g:github_dashboard['open_command'] = 'open'
"
"                " API timeout in seconds - Default: 10, 20
"            let g:github_dashboard['api_open_timeout'] = 10
"            let g:github_dashboard['api_read_timeout'] = 20
"
"                " Do not set statusline - Then you can customize your
"                " own statusline with github_dashboard#status()
"            let g:github_dashboard['statusline'] = 0
"
"                " GitHub Enterprise
"            let g:github_dashboard['api_endpoint'] =
"                                   \ 'http://github.mycorp.com/api/v3'
"            let g:github_dashboard['web_endpoint'] =
"                                   \ 'http://github.mycorp.com'
"




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" PYTHON """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"jedi-vim is a VIM binding to the autocompletion Python library Jedi.
"		Plug 'davidhalter/jedi-vim', { 'for': ['python'] }

"if (&ft=='python')
"
"			"Configuration: TODO
"endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TDD in Python
		Plug 'alfredodeza/pytest.vim', { 'for': ['python'] }
"if (&ft=='python')
"endif






""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" C / C++ """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""Will be a C/C++ IDE - Write and run programs. Insert statements, idioms,
""comments etc. by use of templates. Provides code handling also.
"    Plug 'https://github.com/vim-scripts/c.vim' ""SLOW
"
"        let g:C_SourceCodeExtensions  = 'c h cc hh cp cxx cpp CPP c++ C i ii'
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" PLANTUML """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Syntax highlighting file for pantUMl
"        Plug 'https://github.com/aklt/plantuml-syntax', { 'for': ['uml', 'plantuml'] }
if (&ft=='uml' || &ft=='plantuml')
            function! PlantUML()
                    execute ':w'
                    execute ':!java -jar plantuml.jar -o %:p:h %'
                    echohl StatusLine | echo 'Plantuml don ' | echohl None
            endfunction

            augroup PLANTUML
            autocmd FileType plantuml nnoremap <buffer> <F3> :call PlantUML()

            autocmd FileWritePost,BufWritePost,FilterWritePost,FileAppendPost
						\ *.uml,*.pl,*.plantuml :!java -jar plantuml.jar %
						"\ *.uml,*.pl,*.plantuml :!java -jar plantuml.jar -tsvg%
            augroup end
endif




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Render platuml files and display it in browser
"        Plug 'iamcco/markdown-preview.nvim',
"        \ {'do': { -> mkdp#util#install() },'for': ['markdown', 'vim-plug']}





""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" TRACE32 PRACTICE """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Syntax highlighting for lauterbach trace32 practice script
        "Plug 'https://github.com/m42e/trace32-practice.vim'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Other stuff """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Yank a text to x register and than makes it easy by one key to replace a text
"area by the yanked text. Nothing more, can be done by vim directly
        Plug 'https://github.com/kana/vim-operator-replace'
            map _  <Plug>(operator-replace)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Yank all lines matched to a preformed search with |:Grey|. After executing you
"can put them elsewhere by |:Grey| again or delete all ines with |:Gret|
        Plug 'kana/vim-grex'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Disables hjkl movements for some seconds to learn better vim motions.
        Plug 'https://github.com/takac/vim-hardtime'

            let g:hardtime_default_on = 1

                "In milliseconds
            let g:hardtime_timeout = 100

            let g:hardtime_ignore_buffer_patterns = [
                \ 'NERD.*']

            let g:hardtime_ignore_quickfix = 1

                "Allow different keys like "jh", but not "jj".
            let g:hardtime_allow_different_key = 1



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Generates an doxygen header for a function with all parameters by |:Dox|
        Plug 'https://github.com/vim-scripts/DoxygenToolkit.vim', { 'for': ['c', 'cpp'] }

if (&ft=='c' || &ft=='cpp')
            let g:DoxygenToolkit_briefTag_pre='@brief    '
            let g:DoxygenToolkit_paramTag_pre='@param    '
            let g:DoxygenToolkit_returnTag='@returns    '
            let g:DoxygenToolkit_blockHeader=''
            let g:DoxygenToolkit_blockFooter=''
            let g:DoxygenToolkit_authorName='Marco Israel'
            let g:DoxygenToolkit_licenseTag=
			\ 'Copyright (c) 2021  Marco Israel. MIT License.'
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Highlights a yank area for examples.
        Plug 'haya14busa/vim-operator-flashy'
        Plug 'kana/vim-operator-user'

            let g:operator#flashy#flash_time = 100
            "let g:operator#flashy#group =
            "    \ 'Flashy         xxx term=bold ctermbg=0 guibg=#13354A'


            map y <Plug>(operator-flashy)
            nmap Y <Plug>(operator-flashy)$


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Opens a browser and searches for the pattern under cursor by <space>-*
"        Plug 'https://github.com/kana/vim-wwwsearch'
"            let g:wwwsearch_command_to_open_uri =  'vimb {uri}'
"            "let g:wwwsearch_command_to_open_uri =  'firefox {uri}'
"            "nnoremap <space>*  :<C-u>Wwwsearch -default <cword><Return>
"            nnoremap  <expr> <space>* ':<C-u>Wwwsearch -default
"                         \ '.expand('<cword>').'<CR>'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Opens URL under cursor or searches for a word (under cursor)
		Plug 'https://github.com/dhruvasagar/vim-open-url'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Makes Session management in vim easier by let the user save, load sessions
        Plug 'https://github.com/xolox/vim-session'
            let g:session_autosave='yes'
            let g:session_directory='~/.vim/sessions'
            let g:session_autosave_to='~/.vim/sessions/autosave'
            let g:session_lock_directory='~/.vim/sessions/locks'
            "let g:session_extension='_'.strftime('%Y%m%d%H-%M%S')
            let g:session_autosave_silent=1
            let g:session_autoload='yes'
            let g:session_lock_enabled=0
            let g:session_default_overwrite =1
            let g:session_autosave_periodic = 1 "interval for autosave in min
            let g:session_command_aliases = 1 "for :'Session'*<tab>
            let g:session_menu = 1
            let g:session_default_namea = 'last'
            let g:session_default_to_last=1
            set sessionoptions-=help
            "set sessionoptions-=options
            "let g:loaded_session = 1 "avoid loading the vim


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"A collection of language packs plugins for in one plugin. Lots of syntax files
        Plug 'sheerun/vim-polyglot'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Provides functions to handle withe spaces in a file like find and deletion.
"Because it scans the fie by default (on every write) this can SLOW vim down.!
"To simple highlight trailing white spaces, use vim builtin.
"        Plug 'https://github.com/ntpeters/vim-better-whitespace'
"
"
"            let g:better_whitespace_enabled=1
"            let g:strip_whitespace_on_save=1
"            let g:current_line_whitespace_disabled_hard=1
"            let g:current_line_whitespace_disabled_soft=1
"            let g:better_whitespace_operator='_s'
"            let g:strip_max_file_size = 1000
"            let g:strip_whitespace_confirm=0
"            let g:strip_only_modified_lines=1
"            let g:diff_binary='/usr/local/bin/diff -E'
"            let g:strip_whitelines_at_eof=1
"            let g:show_spaces_that_precede_tabs=1
"            let g:better_whitespace_skip_empty_lines=1
"            let g:better_whitespace_filetypes_blacklist=[
"            let g:better_whitespace_verbosity=1
"                \'diff',
"                \ 'gitcommit',
"                \ 'unite',
"                \'qf',
"                \'help']
"
"
"                " highlight whitespace in markdown files, though stripping
"                " remains disabled by the blacklist
"            autocmd FileType markdown EnableWhitespace
"
"                " Do not modify kernel files, even though their type
"                " not blacklisted and highlighting  enabled
"            autocmd BufRead /usr/src/linux* DisableStripWhitespaceOnSave
"
"            nnoremap ]w :NextTrailingWhitespace<CR>
"            nnoremap [w :PrevTrailingWhitespace<CR>
"
"            map <C-F9> :call StripTrailingWhitespaces()


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Provides a powerful calculator inside vim by executing |:Calculator|
"This opens a new window where expressions can be make. Supports Variables but
"you cant use it for visual select or direct past result into the line.
"        Plug 'https://github.com/fedorenchik/calculator.vim.git'
"            let g:calculator_prompt = '>> '


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" An other calculator inside vim on Commandline or by visual selection.
"
"        Plug 'arecarn/crunch'
"        Plug 'arecarn/vim-selection'
"
"            let g:crunch_prompt = '>>'                 "Default 'Calc >> '
"            let g:crunch_comment = '"'                 "Default '"'
"            let g:crunch_result_type_append = 1
"                               \ "Default 1. 0 Replace line by result
"            let g:crunch_user_variables =
"                               \ {'e': exp(1),'pi':3.14159265359}  "Default {}
"            let g:crunch_precision = 6                 "Default 6
"


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"From
"http://vimcasts.org/episodes/simple-calculations-with-vims-expression-register/

"Use of vims expression register . Past it into cursor place.
        "Simple on command line on command line press:
            "<C-r>=

"Calculate the term from the beginning of the line TILL an REQUIRED '='.
        nnoremap \lcalc 0yt=A<C-r>=<C-r>"<CR><Esc>


"From "https://vim.fandom.com/wiki/Using_vim_as_calculator
"Use Linux bc on line in INSERT or VISUAL selection. REPLACEs the current line.
        "Pipe the CURRENT LINE to bc and REPLACE with it with the result:
            "!!bc
        "Pipe the VISUAL selected inbc and REPLACE with it with the result:
            "!bc

"Calculate the term from the beginning of the line TILL CURSOR. Adds '=' before
        inoremap \elcalc <C-O>yiW<End>=<C-R>=<C-R>0<CR>

"Calculate the CURRENT LINE by Linux bc.
        map \lecalc yypkA =<Esc>jOscale=2<Esc>:.,+1!bc<CR>kJ

"Calculate VISUAL BLOCK of Numbers and insert result IN A NEW LINE.
        vmap \bclac "y'>p:'[,']-1s/$/+/\|'[,']+1j!<CR>
            \ '[0"wy$:.s§.*§\=w§<CR>'[yyP:.s/./=/g<CR>_j





""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" TMUX
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Support to more easy configure tmux.conf in vim
		Plug 'tmux-plugins/vim-tmux'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Prefome Commands direct to Tmux shell (bash) by opening a terminal split.
		Plug 'benmills/vimux'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Provide interaction / integration between tmux and vim
        Plug 'https://github.com/christoomey/vim-tmux-navigator'

            " Activate autoupdate on exit
         let g:tmux_navigator_save_on_switch = 1

            " Disable vim->tmux navigation when the Vim pane is zoomed in tmux
         let g:tmux_navigator_disable_when_zoomed = 1

            " Custom Key Bindings
         let g:tmux_navigator_no_mappings = 1

		if exists('$TMUX')
		  function! TmuxOrSplitSwitch(wincmd, tmuxdir)
		    let previous_winnr = winnr()
		    silent! execute "wincmd " . a:wincmd
		    if previous_winnr == winnr()
		      call system("tmux select-pane -" . a:tmuxdir)
		      redraw!
		    endif
		  endfunction

		  let previous_title = substitute(system(
			  \ "tmux display-message -p '#{pane_title}'"), '\n', '', '')
		  let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
		  let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

		  nnoremap <silent> <C-h> :call TmuxOrSplitSwitch('h', 'L')<cr>
		  nnoremap <silent> <C-j> :call TmuxOrSplitSwitch('j', 'D')<cr>
		  nnoremap <silent> <C-k> :call TmuxOrSplitSwitch('k', 'U')<cr>
		  nnoremap <silent> <C-l> :call TmuxOrSplitSwitch('l', 'R')<cr>
		else
		  map <C-h> <C-w>h
		  map <C-j> <C-w>j
		  map <C-k> <C-w>k
		  map <C-l> <C-w>l
		endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim plugin for completion of words in adjacent tmux panes. E.g. if you need
" to type a " word that you can see in a different Tmux pane right next to Vim.
        Plug 'wellle/tmux-complete.vim'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Status line """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Light status line configuration plugin. Easy to configure.
"       Plug 'itchyny/lightline.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"More complex statusline. More configuration  needed.
"       Plug 'https://vimawesome.com/plugin/vim-airline-superman'



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Different types of plugins """""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Create your own text objects. Need and used by a lot of plugins
        Plug 'kana/vim-textobj-user'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Vim libraries with utility functions used/needed by a lot of Vim plugins.
        Plug 'https://github.com/vim-jp/vital.vim'
        Plug 'https://github.com/xolox/vim-misc'
        Plug 'https://github.com/Shougo/vimproc.vim'

        "ATTATION: Should be always active


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Asyncron run commands in background. Automatically for buildin commands like
"make. Or by calling AsycRun <shellCMD>
        Plug 'https://github.com/tpope/vim-dispatch'
        Plug 'https://github.com/skywind3000/asyncrun.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Helping writeing, debuging or prefomance test of vinscripts.
"Parse output of massages like :verbose ore errors into a preview/quickfix
"        Plug 'tpope/vim-scriptease'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"NFTables syntax color file
        Plug 'nfnty/vim-nftables'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim LanguageTool is a grammar and spell checker.
        Plug 'dpelle/vim-LanguageTool'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim plugin to control splits with visual selections or text objects
" via VSSplit VSSplitAbove VSSplitBelow ...
        Plug 'wellle/visual-split.vim'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Simple E-Mail Client in vim
"		Plug 'soywod/iris.vim'
"
"		"Identity (required)
"	let g:iris_name  = "My name"
"	let g:iris_mail = "your@mail.com"
"
"		"IMAP (required)
"	let g:iris_imap_host  = "your.imap.host"
"	let g:iris_imap_port  = 993
"	let g:iris_imap_login = "Your IMAP login" "Default to g:iris_mail
"
"		"SMTP (required)
"	let g:iris_smtp_host  = "your.smtp.host" "Default to g:iris_imap_host
"	let g:iris_smtp_port  = 587
"	let g:iris_smtp_login = "Your IMAP login" "Default to g:iris_mail Passwords
"
"		"On startup, Iris always asks for your IMAP and SMTP passwords.
"		"To avoid this, you can save your password in a file and encrypt
"		"it via GPG: "gpg --encrypt --sign --armor --output myfile.gpg myfile"
"		"Note: You need to use absolute pathes
"	let g:iris_imap_passwd_filepath = "/path/to/imap.gpg"
"	let g:iris_smtp_passwd_filepath = "/path/to/smtp.gpg"
"
"		"Autostart and latency
"	let g:iris_idle_enabled = 0
"	let g:iris_idle_timeout = 15
"
"		"By default, Iris fetches your last 50 mails:
"	let g:iris_emails_chunk_size = 50
"
"		"Attachments
"	let g:iris_download_dir = "~/Downloads"



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 "Open and close Qickfix and location list in a cycle (see below)
		Plug 'https://github.com/Valloric/ListToggle'
		Plug 'https://github.com/drmingdrmer/vim-toggle-quickfix'

		nmap <Leader>o <Plug>window:quickfix:loop
		let g:lt_location_list_toggle_map = '<leader><leader>l'
		let g:lt_quickfix_list_toggle_map = '<leader><leader>q'
		let g:lt_height = 10



				"----------------------------------------------
				"USAGE:
				"----------------------------------------------
				"                        quickfix  locationlist
				"                        --------  ------------
				"                        closed    closed
				"<C-g><C-o> once         open      closed
				"<C-g><C-o> twice        closed    open
				"<C-g><C-o> three times  closed    closed
				"<C-g><C-o> forth times  ...
				"----------------------------------------------

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Opening a file in a given line when press gf to filename:linename under cursor
		Plug 'https://github.com/bogado/file-line'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :TableMode to activate a table cration mode with formulas and csv conversion
		Plug 'https://github.com/dhruvasagar/vim-table-mode'
		let g:table_mode_corner_corner='+'
		let g:table_mode_header_fillchar='='
		let g:table_mode_corner='+'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" Interactive draw diagrams in vim after starting DrawIt
"		Plug  'vim-scripts/DrawIt'




call plug#end()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim:tw=80:ts=4:syntax=vim:
